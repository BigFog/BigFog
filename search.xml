<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Studio+夜神模拟器 动态调试APK</title>
    <url>/2018/03/03/Android%20Studio+%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95APK/</url>
    <content><![CDATA[<h2 id="1-smali文件格式"><a href="#1-smali文件格式" class="headerlink" title="1 smali文件格式"></a>1 smali文件格式</h2><table>
<thead>
<tr>
<th align="left">头部定义</th>
<th align="center">域定义</th>
<th align="right">函数定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="center">.field public</td>
<td align="right">.method</td>
</tr>
<tr>
<td align="left">.super</td>
<td align="center">.field static</td>
<td align="right">instruction</td>
</tr>
<tr>
<td align="left">.source</td>
<td align="center">.field private</td>
<td align="right">.endmethod</td>
</tr>
<tr>
<td align="left"><a id="more"></a></td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">## 2 准备</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">Android studio（简称AS）</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">smalidea-0.05.zip(插件)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">android killer(修改smali文件)</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">夜神模拟器</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">实验程序 crakme02.apk</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">### 2.1 修改AndroidManifest.xml</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">使用apktool.jar反编译apk。命令：java -jar apktool.jar d -f xxx.apk</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">会生成xxx文件夹。动态调试需要在AndroidManifest.xml添加可调试属性android:debuggable=”true”</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left"><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p1.jpg" alt="xml表"></td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">修改后同样使用apktool.jar进行回编译。命令：java -jar apktool.jar b -f xxx.apk（未签名）</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">打包后的apk并没有签名。可以使用jdk自带的keytool生成keystore,然后使用jarsigner进行签名。</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">以上过程可以使用一些工具来进行修改。反编译后的xxx文件夹是加载到android studio中的源代码。回编译的apk是安装在夜神模拟器中的。</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">### 2.2 AS安装smalidea插件</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">这里的smalidea-0.05.zip插件是下载好的。</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">依次点击File–&gt;setting–&gt;Plugins点击</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left"><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p2.jpg" alt="安装选取"></td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">从磁盘安装后点击apply–&gt;ok–&gt;重启即可</td>
<td align="center"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">### 2.3 夜神模拟器连接DDMS</td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<ol>
<li>启动模拟器</li>
<li>cd进入到夜神安装bin目录下，执行命令nox_adb.exe connect 127.0.0.1:62001</li>
<li>如果命令执行错误。可能是nox_adb.exe版本不对，下载相应版本的替换即可。<br>我这里是配合了环境变量，并将nox_adb.exe connect 127.0.0.1:62001命令做成一个bat。直接运行图方便。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p4.jpg" alt="启动模拟器"><br><strong>模拟器启动后安装回编译并签名的apk</strong><h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3 调试"></a>3 调试</h2><h3 id="3-1-导入源码"><a href="#3-1-导入源码" class="headerlink" title="3.1 导入源码"></a>3.1 导入源码</h3>将反编译的xxx文件夹加载到AS，类似加载一个安卓工程（导入….）界面如下:<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p5.jpg" alt="源码导入"><h3 id="3-2-设置远程调试"><a href="#3-2-设置远程调试" class="headerlink" title="3.2 设置远程调试"></a>3.2 设置远程调试</h3>打开AS，依次点击Run–&gt;edit configurations如图示：<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p6.jpg" alt="配置远程调试"><br>点击+号，添加remote配置。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p7.jpg" alt="添加远程"><br>项目名字随便填，其余地方已用箭头标记<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p8.jpg" alt="配置端口"><h3 id="3-3-打开-Android-device-Monitor"><a href="#3-3-打开-Android-device-Monitor" class="headerlink" title="3.3 打开 Android device Monitor"></a>3.3 打开 Android device Monitor</h3><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p9.jpg" alt="打开ddms"><br>因为模拟器上没有运行什么应用，所以列表中并没有什么应用显示<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p10.jpg" alt="程序列表显示"><h3 id="3-4-下断点并开启调试"><a href="#3-4-下断点并开启调试" class="headerlink" title="3.4 下断点并开启调试"></a>3.4 下断点并开启调试</h3>这是一个检测输入是否正确的apk，所以断点就下到checkSN函数处，在代码最左边单击即可。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p11.jpg" alt="下调试断点"><br>打开cmd  输入 <code>adb shell am start -D -n com.droider.crackme0201/.MainActivity（包名/启动主activity）</code><br>然后模拟器会显示等待调试的弹出框<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p12.jpg" alt="启动调试"><br>接下来就是在AS中启动程序了Run—&gt;debug<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p13.jpg" alt="运行程序"><br>DDMS中也会显示调试程序包名<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p14.jpg" alt="ddms显示"><br>可以看到模拟器已经在程序中启动，而且ddms中红色的甲壳虫也变绿。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p15.png" alt="模拟器显示"><br>接下来我们随意输入，将程序停在所下断点处。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p16.png" alt="断点处"><br>可以看到断点已经停下。后续单步调试，查看变量等操作在这里就不介绍。<br><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/p2-171201/p17.png" alt="变量显示"><br>个人总结过程，仅供参考。</li>
</ol>
]]></content>
      <categories>
        <category>逆向技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>夜神模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2011-0104漏洞分析</title>
    <url>/2018/07/25/CVE-2011-0104%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><blockquote>
<p>CVE-2011-0104是microsoft excel在解析XLB文件时导致的一个溢出。xlb文件是Excel表格里面的一个设置文件，通常记录用户的操作，并非恶意文件。溢出可导致执行任意代码。本文在分析漏洞的基础上，简单利用漏洞弹出计算器。</p>
</blockquote>
<a id="more"></a>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote>
<p>系统：Windows xp pro sp2<br>软件：windows office 2003<br>调试器：immunity Debugger<br>Poc生成：漏洞战争配套资料</p>
</blockquote>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><ul>
<li>打开一个空白的excel程序</li>
<li>打开immunity Debugger,附加excel进程</li>
<li>按下F9将程序运行起来。</li>
<li>在打开的excel中使用file–&gt;open打开配套资料中的exploit.xlb文件。</li>
</ul>
<blockquote>
<p>异常触发：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/1.png" alt="cve-2011-0104"></p>
<blockquote>
<p>可以看到异常是一个访问异常。这时要查找异常产生的源头。向上查看代码，重点关注</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上两个代码是函数开始处的常规操作，向上找可以发现0x300ce252地址处为函数开始。这个就是出错函数的起始位置 </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/2.png" alt="cve-2011-0104"></p>
<blockquote>
<p>再次重新加载程序，在0x300ce252地址处下断点，并对esp栈顶内存下写入断点。这里对此做一个解释，为什么下这个断点呢。因为漏洞在复制数据时会覆盖此地址，此地址是调用0x300ce252函数的返回地址。一旦数据覆盖进行写入操作，就会触发断点，这就定位到了异常出错位置。</p>
</blockquote>
<ul>
<li>打开一个空白的excel程序</li>
<li>打开immunity Debugger,附加excel进程</li>
<li>使用bp 300ce252命令下断点。</li>
<li>按下F9将程序运行起来。</li>
<li>在打开的excel中使用file–&gt;open打开配套资料中的exploit.xlb文件。</li>
<li>程序断下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/3.png" alt="cve-2011-0104"></p>
<blockquote>
<p>内存断点下好后，F9运行，可以看到程序停在了0x300ce3c8地址处，又是一个复制数据出错。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/4.png" alt="cve-2011-0104"></p>
<blockquote>
<p>观察寄存器ebp和edi,之间的大小就是允许复制的数据。计算可得为0x60字节大小。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/5.png" alt="cve-2011-0104"></p>
<blockquote>
<p>分析可知复制了96个字节，edi的值递增覆盖到栈顶0x13aa90,后面利用的跳板地址。单步运行到程序末尾处，返回可以发现是出错复制代码位于call 0x300ce380中。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/6.png" alt="cve-2011-0104"></p>
<blockquote>
<p>为了后面更好的搞清楚栈的覆盖和漏洞利用，有必要梳理下函数调用关系。<br><strong>1.</strong>首先定位在0x300ce252,单步运行程序，一步步通过观察堆栈内容是否覆盖来判断程序调用流程。再次重新加载程序。加载过程同上。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/7.png" alt="cve-2011-0104"></p>
<blockquote>
<p>经过0x302188d8地址处的call excel.306deefe后，栈区被一些乱七八糟的数据填充。可以判断，异常位于这个call中。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/8.png" alt="cve-2011-0104"></p>
<blockquote>
<p><strong>2.</strong>下面要做的就是重新加载程序，在0x302188d8地址处下断点，然后进入call深入分析。<br>进入函数中可以看到。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/9.png" alt="cve-2011-0104"></p>
<blockquote>
<p>梳理总结下流程。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/10.png" alt="cve-2011-0104"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote>
<p>调试分析可以总结得到，数据覆盖的是sub_300ce252函数的返回地址。也就是栈地址0x13aa90。有了返回地址，还要注意到返回时的ret 2c指令，收回了44个空间大小的数据。这样基本就可以完成漏洞利用了。但当程序运行到0x300CE361处的MOV DWORD PTR DS:[EAX],ECX时出现访问违例：访问到一个不可写的地址0x51453844，此时EAX=0x51453844，向上回溯程序，找出EAX的赋值处，发现在0x300CE354处出现给EAX赋值的操作: MOV EAX, DWORD PTR SS:[EBP+2C]，此时EBP=0x0013AA8C,EBP+2C=0x0013AAB8,0x0013AAB8处的值恰好是0x51453844。观察栈中的数据，51453844恰好又是shellcode中的数据。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/11.png" alt="cve-2011-0104"></p>
<blockquote>
<p>根据栈区和样本数据中对应出现的数据，修改相应数值，并添加shellcode。即可利用。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/12.png" alt="cve-2011-0104"></p>
<blockquote>
<p>利用效果</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BigFog/Photo_Save/master/180725/13.png" alt="cve-2011-0104"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这次由于时间原因，写的比较仓促可能具体细节不怎么具体。后续再补上，欢迎交流指导。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0104" target="_blank" rel="noopener">cve-2011-0104</a><br><a href="https://bbs.pediy.com/thread-217940.htm" target="_blank" rel="noopener">看雪的精品文章</a><br><a href="http://www.cnblogs.com/Ox9A82" target="_blank" rel="noopener">Ox9A82</a><br><a href="https://www.securityfocus.com/bid/47245" target="_blank" rel="noopener">安全焦点</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>文档漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
</search>
